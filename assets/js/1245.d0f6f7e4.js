(window.webpackJsonp=window.webpackJsonp||[]).push([[1245],{1566:function(e,t,i){"use strict";i.r(t);var s=i(1),r=Object(s.a)({},(function(){var e=this,t=e.$createElement,i=e._self._c||t;return i("div",{staticClass:"content"},[e._m(0),e._v(" "),i("p",[e._v("下面介绍四种常用数据操控操作，分别是插入，更新，删除和TTL设置")]),e._v(" "),e._m(1),e._v(" "),e._m(2),e._v(" "),e._m(3),e._v(" "),e._m(4),e._v(" "),e._m(5),e._v(" "),e._m(6),e._v(" "),i("p",[e._v("目前不支持数据的原地更新操作，即update语句，但用户可以直接插入新的数据，在同一个时间点上的同一个时间序列以最新插入的数据为准\n旧数据会通过合并来自动删除，参见：")]),e._v(" "),i("ul",[i("li",[i("router-link",{attrs:{to:"/zh/SystemDesign/4-StorageEngine/4-MergeManager.html"}},[e._v("文件合并机制")])],1)]),e._v(" "),e._m(7),e._v(" "),e._m(8),e._v(" "),i("p",[e._v("每个 StorageGroupProsessor 中针对每个分区会维护一个自增的版本号，由 SimpleFileVersionController 管理。\n每个内存缓冲区 memtable 在持久化的时候会申请一个版本号。持久化到 TsFile 后，会在 TsFileMetadata 中记录此 memtable 对应的 多个 ChunkGroup 的终止位置和版本号。\n查询时会根据此信息对 ChunkMetadata 赋 version。")]),e._v(" "),e._m(9),e._v(" "),e._m(10),e._v(" "),e._m(11),e._v(" "),i("p",[e._v("同时，我们在 StorageEngine 中启动了一个定时检查文件TTL的线程，详见")]),e._v(" "),e._m(12)])}),[function(){var e=this.$createElement,t=this._self._c||e;return t("h1",{attrs:{id:"数据增删改"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据增删改"}},[this._v("#")]),this._v(" 数据增删改")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"数据插入"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据插入"}},[this._v("#")]),this._v(" 数据插入")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"单行数据（一个设备一个时间戳多个值）写入"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单行数据（一个设备一个时间戳多个值）写入"}},[this._v("#")]),this._v(" 单行数据（一个设备一个时间戳多个值）写入")])},function(){var e=this,t=e.$createElement,i=e._self._c||t;return i("ul",[i("li",[i("p",[e._v("对应的接口")]),e._v(" "),i("ul",[i("li",[e._v("JDBC 的 execute 和 executeBatch 接口")]),e._v(" "),i("li",[e._v("Session 的 insert 和 insertInBatch")])])]),e._v(" "),i("li",[i("p",[e._v("总入口: public void insert(InsertPlan insertPlan)   StorageEngine.java")]),e._v(" "),i("ul",[i("li",[e._v("找到对应的 StorageGroupProcessor")]),e._v(" "),i("li",[e._v("根据写入数据的时间以及当前设备落盘的最后时间戳，找到对应的 TsFileProcessor")]),e._v(" "),i("li",[e._v("记录写前日志")]),e._v(" "),i("li",[e._v("写入 TsFileProcessor 对应的 memtable 中\n"),i("ul",[i("li",[e._v("如果是乱序文件，则更新tsfileResource中的endTimeMap")]),e._v(" "),i("li",[e._v("如果tsfile中没有该设备的信息，则更新tsfileResource中的startTimeMap")])])]),e._v(" "),i("li",[e._v("根据 memtable 大小，来判断是否触发异步持久化 memtable 操作\n"),i("ul",[i("li",[e._v("如果是顺序文件且执行了刷盘动作，则更新tsfileResource中的endTimeMap")])])]),e._v(" "),i("li",[e._v("根据当前磁盘 TsFile 的大小，判断是否触发文件关闭操作")])])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"批量数据（一个设备多个时间戳多个值）写入"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#批量数据（一个设备多个时间戳多个值）写入"}},[this._v("#")]),this._v(" 批量数据（一个设备多个时间戳多个值）写入")])},function(){var e=this,t=e.$createElement,i=e._self._c||t;return i("ul",[i("li",[i("p",[e._v("对应的接口")]),e._v(" "),i("ul",[i("li",[e._v("Session 的 insertBatch")])])]),e._v(" "),i("li",[i("p",[e._v("总入口: public Integer[] insertBatch(BatchInsertPlan batchInsertPlan)  StorageEngine.java")]),e._v(" "),i("ul",[i("li",[e._v("找到对应的 StorageGroupProcessor")]),e._v(" "),i("li",[e._v("根据这批数据的时间以及当前设备落盘的最后时间戳，将这批数据分成小批，分别对应到一个 TsFileProcessor 中")]),e._v(" "),i("li",[e._v("记录写前日志")]),e._v(" "),i("li",[e._v("分别将每小批写入 TsFileProcessor 对应的 memtable 中\n"),i("ul",[i("li",[e._v("如果是乱序文件，则更新tsfileResource中的endTimeMap")]),e._v(" "),i("li",[e._v("如果tsfile中没有该设备的信息，则更新tsfileResource中的startTimeMap")])])]),e._v(" "),i("li",[e._v("根据 memtable 大小，来判断是否触发异步持久化 memtable 操作\n"),i("ul",[i("li",[e._v("如果是顺序文件且执行了刷盘动作，则更新tsfileResource中的endTimeMap")])])]),e._v(" "),i("li",[e._v("根据当前磁盘 TsFile 的大小，判断是否触发文件关闭操作")])])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"数据更新"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据更新"}},[this._v("#")]),this._v(" 数据更新")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"数据删除"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据删除"}},[this._v("#")]),this._v(" 数据删除")])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("对应的接口\n"),t("ul",[t("li",[this._v("JDBC 的 execute 接口，使用delete SQL语句")])])])])},function(){var e=this,t=e.$createElement,i=e._self._c||t;return i("ul",[i("li",[e._v("总入口: public void delete(String deviceId, String measurementId, long timestamp) StorageEngine.java\n"),i("ul",[i("li",[e._v("找到对应的 StorageGroupProcessor")]),e._v(" "),i("li",[e._v("找到受影响的所有 working TsFileProcessor 记录写前日志")]),e._v(" "),i("li",[e._v("找到受影响的所有 TsFileResource，在其对应的 mods 文件中记录一条记录：path，deleteTime，version")]),e._v(" "),i("li",[e._v("如果文件没有关闭，拿到对应的 TsFileProcessor\n"),i("ul",[i("li",[e._v("如果存在 working memtable：则删除内存中的数据")]),e._v(" "),i("li",[e._v("如果存在 正在 flush 的 memtable，记录一条记录，查询时跳过删掉的数据（注意此时文件中已经为这些 memtable 记录了 mods）")])])])])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"数据ttl设置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据ttl设置"}},[this._v("#")]),this._v(" 数据TTL设置")])},function(){var e=this,t=e.$createElement,i=e._self._c||t;return i("ul",[i("li",[i("p",[e._v("对应的接口")]),e._v(" "),i("ul",[i("li",[e._v("JDBC 的 execute 接口，使用SET TTL语句")])])]),e._v(" "),i("li",[i("p",[e._v("总入口: public void setTTL(String storageGroup, long dataTTL) StorageEngine.java")]),e._v(" "),i("ul",[i("li",[e._v("找到对应的 StorageGroupProcessor")]),e._v(" "),i("li",[e._v("在 StorageGroupProcessor 中设置新的data ttl")]),e._v(" "),i("li",[e._v("对所有TsfileResource进行TTL检查")]),e._v(" "),i("li",[e._v("如果某个文件在当前TTL下失效，则删除文件")])])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("src/main/java/org/apache/iotdb/db/engine/StorageEngine.java 中的 start 方法")])])}],!1,null,null,null);t.default=r.exports}}]);