(window.webpackJsonp=window.webpackJsonp||[]).push([[475],{1100:function(e,a,s){"use strict";s.r(a);var t=s(83),r=Object(t.a)({},(function(){var e=this,a=e.$createElement,s=e._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"查询基础组件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#查询基础组件"}},[e._v("#")]),e._v(" 查询基础组件")]),e._v(" "),s("h2",{attrs:{id:"设计原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#设计原理"}},[e._v("#")]),e._v(" 设计原理")]),e._v(" "),s("p",[e._v("IoTDB server 模块共提供 3 种不同形式的针对单个时间序列的读取接口，以支持不同形式的查询。")]),e._v(" "),s("ul",[s("li",[e._v("原始数据查询接口，返回 BatchData，可带时间过滤条件或值过滤条件，两种过滤不可同时存在。")]),e._v(" "),s("li",[e._v("聚合查询接口 （主要用于聚合查询和降采样查询）")]),e._v(" "),s("li",[e._v("按递增时间戳查询对应值的接口（主要用于带值过滤的查询）")])]),e._v(" "),s("h2",{attrs:{id:"相关接口"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#相关接口"}},[e._v("#")]),e._v(" 相关接口")]),e._v(" "),s("p",[e._v("以上三种读取单个时间序列数据的方式对应代码里的三个接口")]),e._v(" "),s("h3",{attrs:{id:"org-apache-iotdb-tsfile-read-reader-ibatchreader"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#org-apache-iotdb-tsfile-read-reader-ibatchreader"}},[e._v("#")]),e._v(" org.apache.iotdb.tsfile.read.reader.IBatchReader")]),e._v(" "),s("h4",{attrs:{id:"主要方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#主要方法"}},[e._v("#")]),e._v(" 主要方法")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// 判断是否还有 BatchData\nboolean hasNextBatch() throws IOException;\n\n// 获得下一个 BatchData，并把游标后移\nBatchData nextBatch() throws IOException;\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br")])]),s("h4",{attrs:{id:"使用流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用流程"}},[e._v("#")]),e._v(" 使用流程")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("while (batchReader.hasNextBatch()) {\n\tBatchData batchData = batchReader.nextBatch();\n\t\n\t// use batchData to do some work\n\t...\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br")])]),s("h3",{attrs:{id:"org-apache-iotdb-db-query-reader-series-iaggregatereader"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#org-apache-iotdb-db-query-reader-series-iaggregatereader"}},[e._v("#")]),e._v(" org.apache.iotdb.db.query.reader.series.IAggregateReader")]),e._v(" "),s("h4",{attrs:{id:"主要方法-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#主要方法-2"}},[e._v("#")]),e._v(" 主要方法")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// 判断是否还有 Chunk\nboolean hasNextChunk() throws IOException;\n\n// 判断是否能够使用当前 Chunk 的统计信息\nboolean canUseCurrentChunkStatistics();\n\n// 获得当前 Chunk 的统计信息\nStatistics currentChunkStatistics();\n\n// 跳过当前 Chunk\nvoid skipCurrentChunk();\n\n// 判断当前 Chunk 是否还有下一个 Page\nboolean hasNextPage() throws IOException;\n\n// 判断能否使用当前 Page 的统计信息\nboolean canUseCurrentPageStatistics() throws IOException;\n\n// 获得当前 Page 的统计信息\nStatistics currentPageStatistics() throws IOException;\n\n// 跳过当前的 Page\nvoid skipCurrentPage();\n\n// 获得当前 Page 的数据\nBatchData nextPage() throws IOException;\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br"),s("span",{staticClass:"line-number"},[e._v("25")]),s("br"),s("span",{staticClass:"line-number"},[e._v("26")]),s("br")])]),s("h4",{attrs:{id:"一般使用流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一般使用流程"}},[e._v("#")]),e._v(" 一般使用流程")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("while (aggregateReader.hasNextChunk()) {\n  if (aggregateReader.canUseCurrentChunkStatistics()) {\n    Statistics chunkStatistics = aggregateReader.currentChunkStatistics();\n    \n    // 用 chunk 层的统计信息计算\n    ...\n    \n    aggregateReader.skipCurrentChunk();\n    continue;\n  }\n  \n  // 把当前 chunk 中的 page 消耗完\n  while (aggregateReader.hasNextPage()) {\n\t if (aggregateReader.canUseCurrentPageStatistics()) {\n\t   // 可以用统计信息\n\t   Statistics pageStatistic = aggregateReader.currentPageStatistics();\n\t   \n\t   // 用 page 层的统计信息计算\n\t   ...\n\t  \n\t   aggregateReader.skipCurrentPage();\n\t   continue;\n\t } else {\n\t   // 不能用统计信息，需要用数据计算\n\t   BatchData batchData = aggregateReader.nextOverlappedPage();\n\t   \n\t   // 用 batchData 计算\n\t   ...\n\t }\n  }\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br"),s("span",{staticClass:"line-number"},[e._v("25")]),s("br"),s("span",{staticClass:"line-number"},[e._v("26")]),s("br"),s("span",{staticClass:"line-number"},[e._v("27")]),s("br"),s("span",{staticClass:"line-number"},[e._v("28")]),s("br"),s("span",{staticClass:"line-number"},[e._v("29")]),s("br"),s("span",{staticClass:"line-number"},[e._v("30")]),s("br"),s("span",{staticClass:"line-number"},[e._v("31")]),s("br")])]),s("h3",{attrs:{id:"org-apache-iotdb-db-query-reader-ireaderbytimestamp"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#org-apache-iotdb-db-query-reader-ireaderbytimestamp"}},[e._v("#")]),e._v(" org.apache.iotdb.db.query.reader.IReaderByTimestamp")]),e._v(" "),s("h4",{attrs:{id:"主要方法-3"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#主要方法-3"}},[e._v("#")]),e._v(" 主要方法")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// 给定一批递增时间戳的值，返回一批结果（减少方法调用次数）\nObject[] getValuesInTimestamps(long[] timestamps, int length) throws IOException;\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br")])]),s("h4",{attrs:{id:"一般使用流程-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一般使用流程-2"}},[e._v("#")]),e._v(" 一般使用流程")]),e._v(" "),s("p",[e._v("该接口在带值过滤的查询中被使用，TimeGenerator 生成时间戳后，使用该接口获得该时间戳对应的 value")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("Object[] values = readerByTimestamp.getValueInTimestamp(timestamps, length);\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("h2",{attrs:{id:"具体实现类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#具体实现类"}},[e._v("#")]),e._v(" 具体实现类")]),e._v(" "),s("p",[e._v("上述三个接口都有其对应的实现类，由于以上三种查询有共性，我们设计了一个基础的 SeriesReader 工具类，封装了对于一个时间序列读取操作的基本方法，帮助实现以上三种接口。下面首先介绍 SeriesReader 的设计原理，然后再依次介绍三个接口的具体实现。")]),e._v(" "),s("h3",{attrs:{id:"org-apache-iotdb-db-query-reader-series-seriesreader"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#org-apache-iotdb-db-query-reader-series-seriesreader"}},[e._v("#")]),e._v(" org.apache.iotdb.db.query.reader.series.SeriesReader")]),e._v(" "),s("h4",{attrs:{id:"设计思想"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#设计思想"}},[e._v("#")]),e._v(" 设计思想")]),e._v(" "),s("p",[e._v("背景知识：TsFile 文件（TsFileResource）解开后可以得到 ChunkMetadata，ChunkMetadata 解开后可以得到一堆 PageReader，PageReader 可以直接返回 BatchData 数据点。")]),e._v(" "),s("p",[e._v("为了支持以上三种接口")]),e._v(" "),s("p",[e._v("数据按照粒度从大到小分成四种：文件，Chunk，Page，相交数据点。在原始数据查询中，最大的数据块返回粒度是一个 page，如果一个 page 和其他 page 由于乱序写入相互覆盖了，就解开成数据点做合并。聚合查询中优先使用 Chunk 的统计信息，其次是 Page 的统计信息，最后是相交数据点。")]),e._v(" "),s("p",[e._v("设计原则是能用粒度大的就不用粒度小的。")]),e._v(" "),s("p",[e._v("首先介绍一下 SeriesReader 里的几个重要字段")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("\n/*\n* 文件层\n*/\nprotected final QueryDataSource dataSource;\n\tQueryDataSource在一个查询中包含一个timeseries的所有seq和unseq TsFileResources\n\t\n/*\n* chunk 层\n*\n* 三个字段之间数据永远不重复，first 永远是第一个（开始时间最小）\n*/\nprotected IChunkMetadata firstChunkMetadata;\n\t填充 chunk 层时优先填充此字段，保证这个 chunk 具有当前最小开始时间\n\t\nprotected final PriorityQueue<IChunkMetadata> cachedChunkMetadata;\n\t文件解开后得到的 ChunkMetaData 存放在此，互相之间可能有重叠，为了保证顺序，使用优先队列进行存储 \n\t\n/*\n* page cache\n*\n* 两个字段之间数据永远不重复，first 永远是第一个（开始时间最小）\n*/\nprotected VersionPageReader firstPageReader;\n\t开始时间最小的 page reader\n\t\nprotected final List<VersionPageReader> seqPageReaders = new LinkedList<>();\n\t顺序 chunk 解开后得到的 page reader 存放在此，本身有序且互不重叠，所以使用 List 存储\n\nprotected final PriorityQueue<VersionPageReader> unSeqPageReaders;\n\t乱序 chunk 解开后得到的 page reader 存放在此，互相之间可能有重叠，为了保证顺序，使用优先队列进行存储 \n\t\n/*\n * 相交数据点层\n */ \nprotected final PriorityMergeReader mergeReader;\n\t本质上是多个带优先级的 page，按时间戳从低到高输出数据点，时间戳相同时，保留优先级高的\n\n/*\n * 相交数据点产出结果的缓存\n */ \nprotected boolean hasCachedNextOverlappedPage;\n\t是否缓存了下一个 batch\n\t\nprotected BatchData cachedBatchData;\n\t缓存的下一个 batch 的引用\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br"),s("span",{staticClass:"line-number"},[e._v("25")]),s("br"),s("span",{staticClass:"line-number"},[e._v("26")]),s("br"),s("span",{staticClass:"line-number"},[e._v("27")]),s("br"),s("span",{staticClass:"line-number"},[e._v("28")]),s("br"),s("span",{staticClass:"line-number"},[e._v("29")]),s("br"),s("span",{staticClass:"line-number"},[e._v("30")]),s("br"),s("span",{staticClass:"line-number"},[e._v("31")]),s("br"),s("span",{staticClass:"line-number"},[e._v("32")]),s("br"),s("span",{staticClass:"line-number"},[e._v("33")]),s("br"),s("span",{staticClass:"line-number"},[e._v("34")]),s("br"),s("span",{staticClass:"line-number"},[e._v("35")]),s("br"),s("span",{staticClass:"line-number"},[e._v("36")]),s("br"),s("span",{staticClass:"line-number"},[e._v("37")]),s("br"),s("span",{staticClass:"line-number"},[e._v("38")]),s("br"),s("span",{staticClass:"line-number"},[e._v("39")]),s("br"),s("span",{staticClass:"line-number"},[e._v("40")]),s("br"),s("span",{staticClass:"line-number"},[e._v("41")]),s("br"),s("span",{staticClass:"line-number"},[e._v("42")]),s("br"),s("span",{staticClass:"line-number"},[e._v("43")]),s("br"),s("span",{staticClass:"line-number"},[e._v("44")]),s("br"),s("span",{staticClass:"line-number"},[e._v("45")]),s("br"),s("span",{staticClass:"line-number"},[e._v("46")]),s("br")])]),s("p",[e._v("下面介绍一下 SeriesReader 里的重要方法")]),e._v(" "),s("h4",{attrs:{id:"hasnextchunk"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hasnextchunk"}},[e._v("#")]),e._v(" hasNextChunk()")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("主要功能：判断该时间序列还有没有下一个 chunk。")])]),e._v(" "),s("li",[s("p",[e._v("约束：在调用这个方法前，需要保证 "),s("code",[e._v("SeriesReader")]),e._v(" 内已经没有 page 和 数据点 层级的数据了，也就是之前解开的 chunk 都消耗完了。")])]),e._v(" "),s("li",[s("p",[e._v("实现：如果 "),s("code",[e._v("firstChunkMetaData")]),e._v(" 不为空，则代表当前已经缓存了第一个 "),s("code",[e._v("ChunkMetaData")]),e._v("，且未被使用，直接返回"),s("code",[e._v("true")]),e._v("；")]),e._v(" "),s("p",[e._v("尝试去解开第一个顺序文件和第一个乱序文件，填充 chunk 层。并解开与 "),s("code",[e._v("firstChunkMetadata")]),e._v(" 相重合的所有文件。")])])]),e._v(" "),s("h4",{attrs:{id:"ischunkoverlapped"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ischunkoverlapped"}},[e._v("#")]),e._v(" isChunkOverlapped()")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("主要功能：判断当前的 chunk 有没有与其他 Chunk 有重叠")])]),e._v(" "),s("li",[s("p",[e._v("约束：在调用这个方法前，需要保证 chunk 层已经缓存了 "),s("code",[e._v("firstChunkMetadata")]),e._v("，也就是调用了 hasNextChunk() 并且为 true。")])]),e._v(" "),s("li",[s("p",[e._v("实现：直接把 "),s("code",[e._v("firstChunkMetadata")]),e._v(" 与 "),s("code",[e._v("seqChunkMetadatas")]),e._v(" 和 "),s("code",[e._v("unseqChunkMetadatas")]),e._v(" 相比较。因为此前已经保证所有和 "),s("code",[e._v("firstChunkMetadata")]),e._v(" 相交的文件都被解开了。")])])]),e._v(" "),s("h4",{attrs:{id:"currentchunkstatistics"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#currentchunkstatistics"}},[e._v("#")]),e._v(" currentChunkStatistics()")]),e._v(" "),s("p",[e._v("返回 "),s("code",[e._v("firstChunkMetaData")]),e._v(" 的统计信息。")]),e._v(" "),s("h4",{attrs:{id:"skipcurrentchunk"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#skipcurrentchunk"}},[e._v("#")]),e._v(" skipCurrentChunk()")]),e._v(" "),s("p",[e._v("跳过当前 chunk。只需要将"),s("code",[e._v("firstChunkMetaData")]),e._v("置为"),s("code",[e._v("null")]),e._v("。")]),e._v(" "),s("h4",{attrs:{id:"hasnextpage"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hasnextpage"}},[e._v("#")]),e._v(" hasNextPage()")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("主要功能：判断 SeriesReader 中还有没有已经解开的 page，如果有相交的 page，就构造 "),s("code",[e._v("cachedBatchData")]),e._v(" 并缓存，否则缓存 "),s("code",[e._v("firstPageReader")]),e._v("。")])]),e._v(" "),s("li",[s("p",[e._v("实现：如果已经缓存了 "),s("code",[e._v("cachedBatchData")]),e._v(" 就直接返回。如果有相交数据点，就构造 "),s("code",[e._v("cachedBatchData")]),e._v("。如果已经缓存了 "),s("code",[e._v("firstPageReader")]),e._v("，就直接返回。")]),e._v(" "),s("p",[e._v("如果当前的 "),s("code",[e._v("firstChunkMetadata")]),e._v(" 还没有解开，就解开与之重叠的所有 ChunkMetadata，构造 firstPageReader。")]),e._v(" "),s("p",[e._v("判断，如果 "),s("code",[e._v("firstPageReader")]),e._v(" 和 "),s("code",[e._v("cachedPageReaders")]),e._v(" 相交，则构造 "),s("code",[e._v("cachedBatchData")]),e._v("，否则直接返回。")])])]),e._v(" "),s("h4",{attrs:{id:"ispageoverlapped"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ispageoverlapped"}},[e._v("#")]),e._v(" isPageOverlapped()")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("主要功能：判断当前的 page 有没有与其他 page 有重叠")])]),e._v(" "),s("li",[s("p",[e._v("约束：在调用这个方法前，需要保证调用了 hasNextPage() 并且为 true。也就是，有可能缓存了一个相交的 "),s("code",[e._v("cachedBatchData")]),e._v("，或者缓存了不相交的 "),s("code",[e._v("firstPageReader")]),e._v("。")])]),e._v(" "),s("li",[s("p",[e._v("实现：先判断有没有 "),s("code",[e._v("cachedBatchData")]),e._v("，如果没有，就说明当前 page 不相交，则 "),s("code",[e._v("mergeReader")]),e._v(" 里没数据。再判断 "),s("code",[e._v("firstPageReader")]),e._v(" 是否与 "),s("code",[e._v("cachedPageReaders")]),e._v(" 中的 page 相交。")])])]),e._v(" "),s("h4",{attrs:{id:"currentpagestatistics"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#currentpagestatistics"}},[e._v("#")]),e._v(" currentPageStatistics()")]),e._v(" "),s("p",[e._v("返回 "),s("code",[e._v("firstPageReader")]),e._v(" 的统计信息。")]),e._v(" "),s("h4",{attrs:{id:"skipcurrentpage"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#skipcurrentpage"}},[e._v("#")]),e._v(" skipCurrentPage()")]),e._v(" "),s("p",[e._v("跳过当前 Page。只需要将 "),s("code",[e._v("firstPageReader")]),e._v(" 置为 null。")]),e._v(" "),s("h4",{attrs:{id:"nextpage"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#nextpage"}},[e._v("#")]),e._v(" nextPage()")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("主要功能：返回下一个相交或不相交的 page")])]),e._v(" "),s("li",[s("p",[e._v("约束：在调用这个方法前，需要保证调用了 hasNextPage() 并且为 true。也就是，有可能缓存了一个相交的 "),s("code",[e._v("cachedBatchData")]),e._v("，或者缓存了不相交的 "),s("code",[e._v("firstPageReader")]),e._v("。")])]),e._v(" "),s("li",[s("p",[e._v("实现：如果 "),s("code",[e._v("hasCachedNextOverlappedPage")]),e._v(" 为 true，说明缓存了一个相交的 page，直接返回 "),s("code",[e._v("cachedBatchData")]),e._v("。否则当前 page 不相交，直接从 firstPageReader 里拿当前 page 的数据。")])])]),e._v(" "),s("h4",{attrs:{id:"hasnextoverlappedpage"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hasnextoverlappedpage"}},[e._v("#")]),e._v(" hasNextOverlappedPage()")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("主要功能：内部方法，用来判断当前有没有重叠的数据，并且构造相交的 page 并缓存。")])]),e._v(" "),s("li",[s("p",[e._v("实现：如果 "),s("code",[e._v("hasCachedNextOverlappedPage")]),e._v(" 为 "),s("code",[e._v("true")]),e._v("，直接返回 "),s("code",[e._v("true")]),e._v("。")]),e._v(" "),s("p",[e._v("否则，先调用 "),s("code",[e._v("tryToPutAllDirectlyOverlappedPageReadersIntoMergeReader()")]),e._v(" 方法，将 "),s("code",[e._v("cachedPageReaders")]),e._v(" 中所有与 "),s("code",[e._v("firstPageReader")]),e._v(" 有重叠的放进 "),s("code",[e._v("mergeReader")]),e._v(" 里。"),s("code",[e._v("mergeReader")]),e._v(" 里维护了一个 "),s("code",[e._v("currentLargestEndTime")]),e._v(" 变量，每次添加进新的 Reader 时被更新，用以记录当前添加进 "),s("code",[e._v("mergeReader")]),e._v(" 的 page 的最大结束时间。\t\n然后先从"),s("code",[e._v("mergeReader")]),e._v("里取出当前最大的结束时间，作为第一批数据的结束时间，记为"),s("code",[e._v("currentPageEndTime")]),e._v("。接着去遍历"),s("code",[e._v("mergeReader")]),e._v("，直到当前的时间戳大于"),s("code",[e._v("currentPageEndTime")]),e._v("。")]),e._v(" "),s("p",[e._v("每从 mergeReader 移出一个点前，我们先要判断是否有与当前时间戳重叠的 file 或者 chunk 或者 page（这里之所以还要再做一次判断，是因为，比如当前 page 是 1-30，和他直接相交的 page 是 20-50，还有一个 page 是 40-60，每取一个点判断一次是想把 40-60 解开），如果有，解开相应的 file 或者 chunk 或者 page，并将其放入"),s("code",[e._v("mergeReader")]),e._v("。完成重叠的判断后，从"),s("code",[e._v("mergeReader")]),e._v("中取出相应数据。")]),e._v(" "),s("p",[e._v("完成迭代后将获得数据缓存在 "),s("code",[e._v("cachedBatchData")]),e._v(" 中，并将 "),s("code",[e._v("hasCachedNextOverlappedPage")]),e._v(" 置为 "),s("code",[e._v("true")]),e._v("。")])])]),e._v(" "),s("h4",{attrs:{id:"nextoverlappedpage"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#nextoverlappedpage"}},[e._v("#")]),e._v(" nextOverlappedPage()")]),e._v(" "),s("p",[e._v("将缓存的"),s("code",[e._v("cachedBatchData")]),e._v("返回，并将"),s("code",[e._v("hasCachedNextOverlappedPage")]),e._v("置为"),s("code",[e._v("false")]),e._v("。")]),e._v(" "),s("h3",{attrs:{id:"org-apache-iotdb-db-query-reader-series-seriesrawdatabatchreader"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#org-apache-iotdb-db-query-reader-series-seriesrawdatabatchreader"}},[e._v("#")]),e._v(" org.apache.iotdb.db.query.reader.series.SeriesRawDataBatchReader")]),e._v(" "),s("p",[s("code",[e._v("SeriesRawDataBatchReader")]),e._v("实现了"),s("code",[e._v("IBatchReader")]),e._v("。")]),e._v(" "),s("p",[e._v("其方法"),s("code",[e._v("hasNextBatch()")]),e._v("的核心判断流程是")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// 有缓存了 batch，直接返回\nif (hasCachedBatchData) {\n  return true;\n}\n\n/*\n * 如果 SeriesReader 里还有 page，返回 page\n */\nif (readPageData()) {\n  hasCachedBatchData = true;\n  return true;\n}\n\n/*\n * 如果 SeriesReader 里还有 chunk，返回 chunk\n */\nif (readChunkData()) {\n  hasCachedBatchData = true;\n  return true;\n}\n\n/*\n * 如果有 File，并且有 chunk，返回 chunk\n */\nwhile (seriesReader.hasNextFile()) {\n  if (readChunkData()) {\n    hasCachedBatchData = true;\n    return true;\n  }\n}\nreturn hasCachedBatchData;\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br"),s("span",{staticClass:"line-number"},[e._v("25")]),s("br"),s("span",{staticClass:"line-number"},[e._v("26")]),s("br"),s("span",{staticClass:"line-number"},[e._v("27")]),s("br"),s("span",{staticClass:"line-number"},[e._v("28")]),s("br"),s("span",{staticClass:"line-number"},[e._v("29")]),s("br"),s("span",{staticClass:"line-number"},[e._v("30")]),s("br"),s("span",{staticClass:"line-number"},[e._v("31")]),s("br")])]),s("h3",{attrs:{id:"org-apache-iotdb-db-query-reader-series-seriesreaderbytimestamp"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#org-apache-iotdb-db-query-reader-series-seriesreaderbytimestamp"}},[e._v("#")]),e._v(" org.apache.iotdb.db.query.reader.series.SeriesReaderByTimestamp")]),e._v(" "),s("p",[s("code",[e._v("SeriesReaderByTimestamp")]),e._v(" 实现了 "),s("code",[e._v("IReaderByTimestamp")]),e._v("。")]),e._v(" "),s("p",[e._v("设计思想：当给一个时间戳要查询值时，这个时间戳可以转化为一个 time >= x 的过滤条件。不断更新这个过滤条件，并且跳过不满足的文件，chunk 和 page。")]),e._v(" "),s("p",[e._v("实现方式：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("/*\n * 优先判断下一个 page 有没有当前所查时间，能跳过就跳过\n */\nif (readPageData(timestamp)) {\n  return true;\n}\n\n/*\n * 判断下一个 chunk 有没有当前所查时间，能跳过就跳过\n */\nif (readChunkData(timestamp)) {\n  return true;\n}\n\n/*\n * 判断下一个 File 有没有当前所查时间，能跳过就跳过\n */\nwhile (seriesReader.hasNextFile()) {\n  Statistics statistics = seriesReader.currentChunkStatistics();\n  if (!satisfyTimeFilter(statistics)) {\n    seriesReader.skipCurrentChunk();\n    continue;\n  }\n  /*\n   * chunk 不能跳过，继续到 chunk 里检查 page\n   */\n  if (readChunkData(timestamp)) {\n    return true;\n  }\n}\nreturn false;\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br"),s("span",{staticClass:"line-number"},[e._v("25")]),s("br"),s("span",{staticClass:"line-number"},[e._v("26")]),s("br"),s("span",{staticClass:"line-number"},[e._v("27")]),s("br"),s("span",{staticClass:"line-number"},[e._v("28")]),s("br"),s("span",{staticClass:"line-number"},[e._v("29")]),s("br"),s("span",{staticClass:"line-number"},[e._v("30")]),s("br"),s("span",{staticClass:"line-number"},[e._v("31")]),s("br")])]),s("h3",{attrs:{id:"org-apache-iotdb-db-query-reader-series-seriesaggregatereader"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#org-apache-iotdb-db-query-reader-series-seriesaggregatereader"}},[e._v("#")]),e._v(" org.apache.iotdb.db.query.reader.series.SeriesAggregateReader")]),e._v(" "),s("p",[s("code",[e._v("SeriesAggregateReader")]),e._v(" 实现了 "),s("code",[e._v("IAggregateReader")])]),e._v(" "),s("p",[s("code",[e._v("IAggregateReader")]),e._v("的大部分接口方法都在"),s("code",[e._v("SeriesReader")]),e._v("有对应实现，除了"),s("code",[e._v("canUseCurrentChunkStatistics()")]),e._v("和"),s("code",[e._v("canUseCurrentPageStatistics()")]),e._v("两个方法。")]),e._v(" "),s("h4",{attrs:{id:"canusecurrentchunkstatistics"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#canusecurrentchunkstatistics"}},[e._v("#")]),e._v(" canUseCurrentChunkStatistics()")]),e._v(" "),s("p",[e._v("设计思想：可以用统计信息的条件是当前 chunk 不重叠，并且满足过滤条件。")]),e._v(" "),s("p",[e._v("先调用"),s("code",[e._v("SeriesReader")]),e._v("的"),s("code",[e._v("currentChunkStatistics()")]),e._v("方法，获得当前 chunk 的统计信息，再调用"),s("code",[e._v("SeriesReader")]),e._v("的"),s("code",[e._v("isChunkOverlapped()")]),e._v("方法判断当前 chunk 是否重叠，如果当前 chunk 不重叠，且其统计信息满足过滤条件，则返回"),s("code",[e._v("true")]),e._v("，否则返回"),s("code",[e._v("false")]),e._v("。")]),e._v(" "),s("h4",{attrs:{id:"canusecurrentpagestatistics"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#canusecurrentpagestatistics"}},[e._v("#")]),e._v(" canUseCurrentPageStatistics()")]),e._v(" "),s("p",[e._v("设计思想：可以用统计信息的条件是当前 page 不重叠，并且满足过滤条件。")]),e._v(" "),s("p",[e._v("先调用"),s("code",[e._v("SeriesReader")]),e._v("的 "),s("code",[e._v("currentPageStatistics()")]),e._v(" 方法，获得当前 page 的统计信息，再调用"),s("code",[e._v("SeriesReader")]),e._v(" 的 "),s("code",[e._v("isPageOverlapped()")]),e._v(" 方法判断当前 page 是否重叠，如果当前 page 不重叠，且其统计信息满足过滤条件，则返回"),s("code",[e._v("true")]),e._v("，否则返回"),s("code",[e._v("false")]),e._v("。")])])}),[],!1,null,null,null);a.default=r.exports}}]);