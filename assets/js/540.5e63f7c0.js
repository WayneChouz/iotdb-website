(window.webpackJsonp=window.webpackJsonp||[]).push([[540],{948:function(t,a,s){"use strict";s.r(a);var r=s(19),v=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"使用说明"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用说明"}},[t._v("#")]),t._v(" 使用说明")]),t._v(" "),a("p",[t._v("触发器提供了一种侦听序列数据变动的机制。配合用户自定义逻辑，可完成告警、数据转发等功能。")]),t._v(" "),a("p",[t._v("触发器基于 Java 反射机制实现。用户通过简单实现 Java 接口，即可实现数据侦听。IoTDB 允许用户动态注册、卸载触发器，在注册、卸载期间，无需启停服务器。")]),t._v(" "),a("h2",{attrs:{id:"侦听模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#侦听模式"}},[t._v("#")]),t._v(" 侦听模式")]),t._v(" "),a("p",[t._v("IoTDB 的单个触发器可用于侦听符合特定模式的时间序列的数据变动，如时间序列 root.sg.a 上的数据变动，或者符合路径模式 root.**.a 的时间序列上的数据变动。您在注册触发器时可以通过 SQL 语句指定触发器侦听的路径模式。")]),t._v(" "),a("h2",{attrs:{id:"触发器类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#触发器类型"}},[t._v("#")]),t._v(" 触发器类型")]),t._v(" "),a("p",[t._v("目前触发器分为两类，您在注册触发器时可以通过 SQL 语句指定类型：")]),t._v(" "),a("ul",[a("li",[t._v("有状态的触发器。该类触发器的执行逻辑可能依赖前后的多条数据，框架会将不同节点写入的数据汇总到同一个触发器实例进行计算，来保留上下文信息，通常用于采样或者统计一段时间的数据聚合信息。集群中只有一个节点持有有状态触发器的实例。")]),t._v(" "),a("li",[t._v("无状态的触发器。触发器的执行逻辑只和当前输入的数据有关，框架无需将不同节点的数据汇总到同一个触发器实例中，通常用于单行数据的计算和异常检测等。集群中每个节点均持有无状态触发器的实例。")])]),t._v(" "),a("h2",{attrs:{id:"触发时机"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#触发时机"}},[t._v("#")]),t._v(" 触发时机")]),t._v(" "),a("p",[t._v("触发器的触发时机目前有两种，后续会拓展其它触发时机。您在注册触发器时可以通过 SQL 语句指定触发时机：")]),t._v(" "),a("ul",[a("li",[t._v("BEFORE INSERT，即在数据持久化之前触发。请注意，目前触发器并不支持数据清洗，不会对要持久化的数据本身进行变动。")]),t._v(" "),a("li",[t._v("AFTER INSERT，即在数据持久化之后触发。")])])])}),[],!1,null,null,null);a.default=v.exports}}]);