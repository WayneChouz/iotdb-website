(window.webpackJsonp=window.webpackJsonp||[]).push([[855],{1415:function(e,t,l){"use strict";l.r(t);var a=l(69),i=Object(a.a)({},(function(){var e=this,t=e.$createElement,l=e._self._c||t;return l("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[l("h1",{attrs:{id:"数据增删改"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#数据增删改"}},[e._v("#")]),e._v(" 数据增删改")]),e._v(" "),l("p",[e._v("下面介绍四种常用数据操控操作，分别是插入，更新，删除和TTL设置")]),e._v(" "),l("h2",{attrs:{id:"数据插入"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#数据插入"}},[e._v("#")]),e._v(" 数据插入")]),e._v(" "),l("h3",{attrs:{id:"单行数据（一个设备一个时间戳多个值）写入"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#单行数据（一个设备一个时间戳多个值）写入"}},[e._v("#")]),e._v(" 单行数据（一个设备一个时间戳多个值）写入")]),e._v(" "),l("ul",[l("li",[l("p",[e._v("对应的接口")]),e._v(" "),l("ul",[l("li",[e._v("JDBC 的 execute 和 executeBatch 接口")]),e._v(" "),l("li",[e._v("Session 的 insertRecord 和 insertRecords")])])]),e._v(" "),l("li",[l("p",[e._v("总入口: public void insert(InsertRowPlan insertRowPlan)   StorageEngine.java")]),e._v(" "),l("ul",[l("li",[e._v("找到对应的 StorageGroupProcessor")]),e._v(" "),l("li",[e._v("根据写入数据的时间以及当前设备落盘的最后时间戳，找到对应的 TsFileProcessor")]),e._v(" "),l("li",[e._v("记录写前日志")]),e._v(" "),l("li",[e._v("写入 TsFileProcessor 对应的 memtable 中\n"),l("ul",[l("li",[e._v("如果是乱序文件，则更新tsfileResource中的endTimeMap")]),e._v(" "),l("li",[e._v("如果tsfile中没有该设备的信息，则更新tsfileResource中的startTimeMap")])])]),e._v(" "),l("li",[e._v("根据 memtable 大小，来判断是否触发异步持久化 memtable 操作\n"),l("ul",[l("li",[e._v("如果是顺序文件且执行了刷盘动作，则更新tsfileResource中的endTimeMap")])])]),e._v(" "),l("li",[e._v("根据当前磁盘 TsFile 的大小，判断是否触发文件关闭操作")])])])]),e._v(" "),l("h3",{attrs:{id:"批量数据（一个设备多个时间戳多个值）写入"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#批量数据（一个设备多个时间戳多个值）写入"}},[e._v("#")]),e._v(" 批量数据（一个设备多个时间戳多个值）写入")]),e._v(" "),l("ul",[l("li",[l("p",[e._v("对应的接口")]),e._v(" "),l("ul",[l("li",[e._v("Session 的 insertTablet")])])]),e._v(" "),l("li",[l("p",[e._v("总入口: public void insertTablet(InsertTabletPlan insertTabletPlan)  StorageEngine.java")]),e._v(" "),l("ul",[l("li",[e._v("找到对应的 StorageGroupProcessor")]),e._v(" "),l("li",[e._v("根据这批数据的时间以及当前设备落盘的最后时间戳，将这批数据分成小批，分别对应到一个 TsFileProcessor 中")]),e._v(" "),l("li",[e._v("记录写前日志")]),e._v(" "),l("li",[e._v("分别将每小批写入 TsFileProcessor 对应的 memtable 中\n"),l("ul",[l("li",[e._v("如果是乱序文件，则更新tsfileResource中的endTimeMap")]),e._v(" "),l("li",[e._v("如果tsfile中没有该设备的信息，则更新tsfileResource中的startTimeMap")])])]),e._v(" "),l("li",[e._v("根据 memtable 大小，来判断是否触发异步持久化 memtable 操作\n"),l("ul",[l("li",[e._v("如果是顺序文件且执行了刷盘动作，则更新tsfileResource中的endTimeMap")])])]),e._v(" "),l("li",[e._v("根据当前磁盘 TsFile 的大小，判断是否触发文件关闭操作")])])])]),e._v(" "),l("h2",{attrs:{id:"数据更新"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#数据更新"}},[e._v("#")]),e._v(" 数据更新")]),e._v(" "),l("p",[e._v("目前不支持数据的原地更新操作，即update语句，但用户可以直接插入新的数据，在同一个时间点上的同一个时间序列以最新插入的数据为准\n旧数据会通过合并来自动删除，参见：")]),e._v(" "),l("ul",[l("li",[l("RouterLink",{attrs:{to:"/zh/SystemDesign/StorageEngine/MergeManager.html"}},[e._v("文件合并机制")])],1)]),e._v(" "),l("h2",{attrs:{id:"数据删除"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#数据删除"}},[e._v("#")]),e._v(" 数据删除")]),e._v(" "),l("ul",[l("li",[e._v("对应的接口\n"),l("ul",[l("li",[e._v("JDBC 的 execute 接口，使用delete SQL语句")])])])]),e._v(" "),l("p",[e._v("每个 StorageGroupProsessor 中针对每个分区会维护一个自增的版本号，由 SimpleFileVersionController 管理。\n每个内存缓冲区 memtable 在持久化的时候会申请一个版本号。持久化到 TsFile 后，会在 TsFileMetadata 中记录此 memtable 对应的 多个 ChunkGroup 的终止位置和版本号。\n查询时会根据此信息对 ChunkMetadata 赋 version。\n​")]),e._v(" "),l("ul",[l("li",[e._v("总入口: public void delete(String deviceId, String measurementId, long timestamp) StorageEngine.java\n"),l("ul",[l("li",[e._v("找到对应的 StorageGroupProcessor")]),e._v(" "),l("li",[e._v("找到受影响的所有 working TsFileProcessor 记录写前日志")]),e._v(" "),l("li",[e._v("找到受影响的所有 TsFileResource，在其对应的 mods 文件中记录一条记录：path，deleteTime，version")]),e._v(" "),l("li",[e._v("如果文件没有关闭，拿到对应的 TsFileProcessor\n"),l("ul",[l("li",[e._v("如果存在 working memtable：则删除内存中的数据")]),e._v(" "),l("li",[e._v("如果存在 正在 flush 的 memtable，记录一条记录，查询时跳过删掉的数据（注意此时文件中已经为这些 memtable 记录了 mods）")])])])])])]),e._v(" "),l("h2",{attrs:{id:"数据ttl设置"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#数据ttl设置"}},[e._v("#")]),e._v(" 数据TTL设置")]),e._v(" "),l("ul",[l("li",[l("p",[e._v("对应的接口")]),e._v(" "),l("ul",[l("li",[e._v("JDBC 的 execute 接口，使用SET TTL语句")])])]),e._v(" "),l("li",[l("p",[e._v("总入口: public void setTTL(String storageGroup, long dataTTL) StorageEngine.java")]),e._v(" "),l("ul",[l("li",[e._v("找到对应的 StorageGroupProcessor")]),e._v(" "),l("li",[e._v("在 StorageGroupProcessor 中设置新的data ttl")]),e._v(" "),l("li",[e._v("对所有TsfileResource进行TTL检查")]),e._v(" "),l("li",[e._v("如果某个文件在当前TTL下失效，则删除文件")])])])]),e._v(" "),l("p",[e._v("同时，我们在 StorageEngine 中启动了一个定时检查文件TTL的线程，详见")]),e._v(" "),l("ul",[l("li",[e._v("src/main/java/org/apache/iotdb/db/engine/StorageEngine.java 中的 start 方法")])])])}),[],!1,null,null,null);t.default=i.exports}}]);