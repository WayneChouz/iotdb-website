import{_ as n}from"./204018765-6fda9391-ebcf-4c80-98c5-26f34bd74df0-c66fd211.js";import{_ as r,a as i}from"./112426760-73e3da80-8d73-11eb-9a8f-9232d1f2033b-7f7de087.js";import{_ as s,a as u}from"./dashboard-33f931cf.js";import{_ as c,E as m,F as l,af as h,G as e,I as t,ag as d,aT as a,C as p}from"./framework-4edf7e71.js";const f={},q=a('<p>Along with IoTDB running, we hope to observe the status of IoTDB, so as to troubleshoot system problems or discover potential system risks in time. A series of metrics that can <strong>reflect the operating status of the system</strong> are system monitoring metrics.</p><h2 id="_1-when-to-use-metric-framework" tabindex="-1"><a class="header-anchor" href="#_1-when-to-use-metric-framework" aria-hidden="true">#</a> 1. When to use metric framework?</h2><p>Belows are some typical application scenarios</p><ol><li><p>System is running slowly</p><p>When system is running slowly, we always hope to have information about system&#39;s running status as detail as possible, such as:</p><ul><li>JVM：Is there FGC? How long does it cost? How much does the memory usage decreased after GC? Are there lots of threads?</li><li>System：Is the CPU usage too hi？Are there many disk IOs？</li><li>Connections：How many connections are there in the current time？</li><li>Interface：What is the TPS and latency of every interface？</li><li>Thread Pool：Are there many pending tasks？</li><li>Cache Hit Ratio</li></ul></li><li><p>No space left on device</p><p>When meet a &quot;no space left on device&quot; error, we really want to know which kind of data file had a rapid rise in the past hours.</p></li><li><p>Is the system running in abnormal status</p><p>We could use the count of error logs、the alive status of nodes in cluster, etc, to determine whether the system is running abnormally.</p></li></ol><h2 id="_2-who-will-use-metric-framework" tabindex="-1"><a class="header-anchor" href="#_2-who-will-use-metric-framework" aria-hidden="true">#</a> 2. Who will use metric framework?</h2><p>Any person cares about the system&#39;s status, including but not limited to RD, QA, SRE, DBA, can use the metrics to work more efficiently.</p><h2 id="_3-what-is-metrics" tabindex="-1"><a class="header-anchor" href="#_3-what-is-metrics" aria-hidden="true">#</a> 3. What is metrics?</h2><h3 id="_3-1-key-concept" tabindex="-1"><a class="header-anchor" href="#_3-1-key-concept" aria-hidden="true">#</a> 3.1. Key Concept</h3><p>In IoTDB&#39;s metric module, each metrics is uniquely identified by <code>Metric Name</code> and <code>Tags</code>.</p><ul><li><code>Metric Name</code>: Metric type name, such as <code>logback_events</code> means log events.</li><li><code>Tags</code>: indicator classification, in the form of Key-Value pairs, each indicator can have 0 or more categories, common Key-Value pairs: <ul><li><code>name = xxx</code>: The name of the monitored object, which is the description of <strong>business logic</strong>. For example, for a monitoring item of type <code>Metric Name = entry_seconds_count</code>, the meaning of name refers to the monitored business interface.</li><li><code>type = xxx</code>: Monitoring indicator type subdivision, which is a description of <strong>monitoring indicator</strong> itself. For example, for monitoring items of type <code>Metric Name = point</code>, the meaning of type refers to the specific type of monitoring points.</li><li><code>status = xxx</code>: The status of the monitored object is a description of <strong>business logic</strong>. For example, for monitoring items of type <code>Metric Name = Task</code>, this parameter can be used to distinguish the status of the monitored object.</li><li><code>user = xxx</code>: The relevant user of the monitored object is a description of <strong>business logic</strong>. For example, count the total points written by the <code>root</code> user.</li><li>Customize according to the specific situation: For example, there is a level classification under logback_events_total, which is used to indicate the number of logs under a specific level.</li></ul></li><li><code>Metric Level</code>: The level of metric managing level, The default startup level is <code>Core</code> level, the recommended startup level is <code>Important level</code>, and the audit strictness is <code>Core &gt; Important &gt; Normal &gt; All</code><ul><li><code>Core</code>: Core metrics of the system, used by the <strong>operation and maintenance personnel</strong>, which is related to the * <em>performance, stability, and security</em>* of the system, such as the status of the instance, the load of the system, etc.</li><li><code>Important</code>: Important metrics of the module, which is used by <strong>operation and maintenance and testers</strong>, and is directly related to <strong>the running status of each module</strong>, such as the number of merged files, execution status, etc.</li><li><code>Normal</code>: Normal metrics of the module, used by <strong>developers</strong> to facilitate <strong>locating the module</strong> when problems occur, such as specific key operation situations in the merger.</li><li><code>All</code>: All metrics of the module, used by <strong>module developers</strong>, often used when the problem is reproduced, so as to solve the problem quickly.</li></ul></li></ul><h3 id="_3-2-external-data-format-for-metrics" tabindex="-1"><a class="header-anchor" href="#_3-2-external-data-format-for-metrics" aria-hidden="true">#</a> 3.2. External data format for metrics</h3><ul><li>IoTDB provides metrics in JMX, Prometheus and IoTDB formats: <ul><li>For JMX, metrics can be obtained through <code>org.apache.iotdb.metrics</code>.</li><li>For Prometheus, the value of the metrics can be obtained through the externally exposed port</li><li>External exposure in IoTDB mode: metrics can be obtained by executing IoTDB queries</li></ul></li></ul><h2 id="_4-the-detail-of-metrics" tabindex="-1"><a class="header-anchor" href="#_4-the-detail-of-metrics" aria-hidden="true">#</a> 4. The detail of metrics</h2><p>Currently, IoTDB provides metrics for some main modules externally, and with the development of new functions and system optimization or refactoring, metrics will be added and updated synchronously.</p>',14),g={href:"https://github.com/apache/iotdb/tree/master/metrics",target:"_blank",rel:"noopener noreferrer"},y=a('<h3 id="_4-1-core-level-metrics" tabindex="-1"><a class="header-anchor" href="#_4-1-core-level-metrics" aria-hidden="true">#</a> 4.1. Core level metrics</h3><p>Core-level metrics are enabled by default during system operation. The addition of each Core-level metrics needs to be carefully evaluated. The current Core-level metrics are as follows:</p><h4 id="_4-1-1-cluster" tabindex="-1"><a class="header-anchor" href="#_4-1-1-cluster" aria-hidden="true">#</a> 4.1.1. Cluster</h4><table><thead><tr><th>Metric</th><th>Tags</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>config_node</td><td>name=&quot;total&quot;,status=&quot;Registered/Online/Unknown&quot;</td><td>AutoGauge</td><td>The number of registered/online/unknown confignodes</td></tr><tr><td>data_node</td><td>name=&quot;total&quot;,status=&quot;Registered/Online/Unknown&quot;</td><td>AutoGauge</td><td>The number of registered/online/unknown datanodes</td></tr><tr><td>cluster_node_leader_count</td><td>name=&quot;{ip}:{port}&quot;</td><td>Gauge</td><td>The count of consensus group leader on each node</td></tr><tr><td>cluster_node_status</td><td>name=&quot;{ip}:{port}&quot;,type=&quot;ConfigNode/DataNode&quot;</td><td>Gauge</td><td>The current node status, 0=Unkonwn 1=online</td></tr><tr><td>entry</td><td>name=&quot;{interface}&quot;</td><td>Timer</td><td>The time consumed of thrift operations</td></tr><tr><td>mem</td><td>name=&quot;IoTConsensus&quot;</td><td>AutoGauge</td><td>The memory usage of IoTConsensus, Unit: byte</td></tr></tbody></table><h4 id="_4-1-2-interface" tabindex="-1"><a class="header-anchor" href="#_4-1-2-interface" aria-hidden="true">#</a> 4.1.2. Interface</h4><table><thead><tr><th>Metric</th><th>Tags</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>thrift_connections</td><td>name=&quot;ConfigNodeRPC&quot;</td><td>AutoGauge</td><td>The number of thrift internal connections in ConfigNode</td></tr><tr><td>thrift_connections</td><td>name=&quot;InternalRPC&quot;</td><td>AutoGauge</td><td>The number of thrift internal connections in DataNode</td></tr><tr><td>thrift_connections</td><td>name=&quot;MPPDataExchangeRPC&quot;</td><td>AutoGauge</td><td>The number of thrift internal connections in MPP</td></tr><tr><td>thrift_connections</td><td>name=&quot;ClientRPC&quot;</td><td>AutoGauge</td><td>The number of thrift connections of Client</td></tr><tr><td>thrift_active_threads</td><td>name=&quot;ConfigNodeRPC-Service&quot;</td><td>AutoGauge</td><td>The number of thrift active internal connections in ConfigNode</td></tr><tr><td>thrift_active_threads</td><td>name=&quot;DataNodeInternalRPC-Service&quot;</td><td>AutoGauge</td><td>The number of thrift active internal connections in DataNode</td></tr><tr><td>thrift_active_threads</td><td>name=&quot;MPPDataExchangeRPC-Service&quot;</td><td>AutoGauge</td><td>The number of thrift active internal connections in MPP</td></tr><tr><td>thrift_active_threads</td><td>name=&quot;ClientRPC-Service&quot;</td><td>AutoGauge</td><td>The number of thrift active connections of client</td></tr><tr><td>session_idle_time</td><td>name = &quot;sessionId&quot;</td><td>Histogram</td><td>The distribution of idle time of different sessions</td></tr></tbody></table><h4 id="_4-1-2-node-statistics" tabindex="-1"><a class="header-anchor" href="#_4-1-2-node-statistics" aria-hidden="true">#</a> 4.1.2. Node Statistics</h4><table><thead><tr><th>Metric</th><th>Tags</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>quantity</td><td>name=&quot;database&quot;</td><td>AutoGauge</td><td>The number of database</td></tr><tr><td>quantity</td><td>name=&quot;timeSeries&quot;</td><td>AutoGauge</td><td>The number of timeseries</td></tr><tr><td>quantity</td><td>name=&quot;pointsIn&quot;</td><td>Counter</td><td>The number of write points</td></tr><tr><td>points</td><td>database=&quot;{database}&quot;, type=&quot;flush&quot;</td><td>Gauge</td><td>The point number of last flushed memtable</td></tr></tbody></table><h4 id="_4-1-3-cluster-tracing" tabindex="-1"><a class="header-anchor" href="#_4-1-3-cluster-tracing" aria-hidden="true">#</a> 4.1.3. Cluster Tracing</h4><table><thead><tr><th>Metric</th><th>Tags</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>performance_overview</td><td>interface=&quot;{interface}&quot;, type=&quot;{statement_type}&quot;</td><td>Timer</td><td>The time consumed of operations in client</td></tr><tr><td>performance_overview_detail</td><td>stage=&quot;authority&quot;</td><td>Timer</td><td>The time consumed on authority authentication</td></tr><tr><td>performance_overview_detail</td><td>stage=&quot;parser&quot;</td><td>Timer</td><td>The time consumed on parsing statement</td></tr><tr><td>performance_overview_detail</td><td>stage=&quot;analyzer&quot;</td><td>Timer</td><td>The time consumed on analyzing statement</td></tr><tr><td>performance_overview_detail</td><td>stage=&quot;planner&quot;</td><td>Timer</td><td>The time consumed on planning</td></tr><tr><td>performance_overview_detail</td><td>stage=&quot;scheduler&quot;</td><td>Timer</td><td>The time consumed on scheduling</td></tr><tr><td>performance_overview_schedule_detail</td><td>stage=&quot;schema_validate&quot;</td><td>Timer</td><td>The time consumed on schema validation</td></tr><tr><td>performance_overview_schedule_detail</td><td>stage=&quot;trigger&quot;</td><td>Timer</td><td>The time consumed on trigger</td></tr><tr><td>performance_overview_schedule_detail</td><td>stage=&quot;consensus&quot;</td><td>Timer</td><td>The time consumed on consensus</td></tr><tr><td>performance_overview_schedule_detail</td><td>stage=&quot;lock&quot;</td><td>Timer</td><td>The time consumed on grabbing lock in DataRegion</td></tr><tr><td>performance_overview_schedule_detail</td><td>stage=&quot;memory_block&quot;</td><td>Timer</td><td>The time consumed on insert memory control</td></tr><tr><td>performance_overview_schedule_detail</td><td>stage=&quot;wal&quot;</td><td>Timer</td><td>The time consumed on writing wal</td></tr><tr><td>performance_overview_schedule_detail</td><td>stage=&quot;memtable&quot;</td><td>Timer</td><td>The time consumed on writing memtable</td></tr><tr><td>performance_overview_schedule_detail</td><td>stage=&quot;last_cache&quot;</td><td>Timer</td><td>The time consumed on updating last cache</td></tr></tbody></table><h4 id="_4-1-5-task-statistics" tabindex="-1"><a class="header-anchor" href="#_4-1-5-task-statistics" aria-hidden="true">#</a> 4.1.5. Task Statistics</h4><table><thead><tr><th>Metric</th><th>Tags</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>queue</td><td>name=&quot;compaction_inner&quot;, status=&quot;running/waiting&quot;</td><td>Gauge</td><td>The number of inner compaction tasks</td></tr><tr><td>queue</td><td>name=&quot;compaction_cross&quot;, status=&quot;running/waiting&quot;</td><td>Gauge</td><td>The number of cross compatcion tasks</td></tr><tr><td>queue</td><td>name=&quot;flush&quot;,status=&quot;running/waiting&quot;</td><td>AutoGauge</td><td>The number of flush tasks</td></tr><tr><td>cost_task</td><td>name=&quot;inner_compaction/cross_compaction/flush&quot;</td><td>Gauge</td><td>The time consumed of compaction tasks</td></tr></tbody></table><h4 id="_4-1-6-iotdb-process" tabindex="-1"><a class="header-anchor" href="#_4-1-6-iotdb-process" aria-hidden="true">#</a> 4.1.6. IoTDB process</h4><table><thead><tr><th>Metric</th><th>Tags</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>process_cpu_load</td><td>name=&quot;process&quot;</td><td>AutoGauge</td><td>The current CPU usage of IoTDB process, Unit: %</td></tr><tr><td>process_cpu_time</td><td>name=&quot;process&quot;</td><td>AutoGauge</td><td>The total CPU time occupied of IoTDB process, Unit: ns</td></tr><tr><td>process_max_mem</td><td>name=&quot;memory&quot;</td><td>AutoGauge</td><td>The maximum available memory of IoTDB process</td></tr><tr><td>process_total_mem</td><td>name=&quot;memory&quot;</td><td>AutoGauge</td><td>The current requested memory for IoTDB process</td></tr><tr><td>process_free_mem</td><td>name=&quot;memory&quot;</td><td>AutoGauge</td><td>The free available memory of IoTDB process</td></tr></tbody></table><h4 id="_4-1-7-system" tabindex="-1"><a class="header-anchor" href="#_4-1-7-system" aria-hidden="true">#</a> 4.1.7. System</h4><table><thead><tr><th>Metric</th><th>Tags</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>sys_cpu_load</td><td>name=&quot;system&quot;</td><td>AutoGauge</td><td>The current CPU usage of system, Unit: %</td></tr><tr><td>sys_cpu_cores</td><td>name=&quot;system&quot;</td><td>Gauge</td><td>The available number of CPU cores</td></tr><tr><td>sys_total_physical_memory_size</td><td>name=&quot;memory&quot;</td><td>Gauge</td><td>The maximum physical memory of system</td></tr><tr><td>sys_free_physical_memory_size</td><td>name=&quot;memory&quot;</td><td>AutoGauge</td><td>The current available memory of system</td></tr><tr><td>sys_total_swap_space_size</td><td>name=&quot;memory&quot;</td><td>AutoGauge</td><td>The maximum swap space of system</td></tr><tr><td>sys_free_swap_space_size</td><td>name=&quot;memory&quot;</td><td>AutoGauge</td><td>The available swap space of system</td></tr><tr><td>sys_committed_vm_size</td><td>name=&quot;memory&quot;</td><td>AutoGauge</td><td>The space of virtual memory available to running processes</td></tr><tr><td>sys_disk_total_space</td><td>name=&quot;disk&quot;</td><td>AutoGauge</td><td>The total disk space</td></tr><tr><td>sys_disk_free_space</td><td>name=&quot;disk&quot;</td><td>AutoGauge</td><td>The available disk space</td></tr></tbody></table><h4 id="_4-1-8-log" tabindex="-1"><a class="header-anchor" href="#_4-1-8-log" aria-hidden="true">#</a> 4.1.8. Log</h4><table><thead><tr><th>Metric</th><th>Tags</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>logback_events</td><td>level=&quot;trace/debug/info/warn/error&quot;</td><td>Counter</td><td>The number of log events</td></tr></tbody></table><h4 id="_4-1-9-file" tabindex="-1"><a class="header-anchor" href="#_4-1-9-file" aria-hidden="true">#</a> 4.1.9. File</h4><table><thead><tr><th>Metric</th><th>Tags</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>file_size</td><td>name=&quot;wal&quot;</td><td>AutoGauge</td><td>The size of WAL file, Unit: byte</td></tr><tr><td>file_size</td><td>name=&quot;seq&quot;</td><td>AutoGauge</td><td>The size of sequence TsFile, Unit: byte</td></tr><tr><td>file_size</td><td>name=&quot;unseq&quot;</td><td>AutoGauge</td><td>The size of unsequence TsFile, Unit: byte</td></tr><tr><td>file_size</td><td>name=&quot;inner-seq-temp&quot;</td><td>AutoGauge</td><td>The size of inner sequence space compaction temporal file</td></tr><tr><td>file_size</td><td>name=&quot;inner-unseq-temp&quot;</td><td>AutoGauge</td><td>The size of inner unsequence space compaction temporal file</td></tr><tr><td>file_size</td><td>name=&quot;cross-temp&quot;</td><td>AutoGauge</td><td>The size of cross space compaction temoporal file</td></tr><tr><td>file_size</td><td>name=&quot;mods</td><td>AutoGauge</td><td>The size of modification files</td></tr><tr><td>file_count</td><td>name=&quot;wal&quot;</td><td>AutoGauge</td><td>The count of WAL file</td></tr><tr><td>file_count</td><td>name=&quot;seq&quot;</td><td>AutoGauge</td><td>The count of sequence TsFile</td></tr><tr><td>file_count</td><td>name=&quot;unseq&quot;</td><td>AutoGauge</td><td>The count of unsequence TsFile</td></tr><tr><td>file_count</td><td>name=&quot;inner-seq-temp&quot;</td><td>AutoGauge</td><td>The count of inner sequence space compaction temporal file</td></tr><tr><td>file_count</td><td>name=&quot;inner-unseq-temp&quot;</td><td>AutoGauge</td><td>The count of inner unsequence space compaction temporal file</td></tr><tr><td>file_count</td><td>name=&quot;cross-temp&quot;</td><td>AutoGauge</td><td>The count of cross space compaction temporal file</td></tr><tr><td>file_count</td><td>name=&quot;open_file_handlers&quot;</td><td>AutoGauge</td><td>The count of open files of the IoTDB process, only supports Linux and MacOS</td></tr><tr><td>file_count</td><td>name=&quot;mods</td><td>AutoGauge</td><td>The count of modification file</td></tr></tbody></table><h4 id="_4-1-10-jvm-memory" tabindex="-1"><a class="header-anchor" href="#_4-1-10-jvm-memory" aria-hidden="true">#</a> 4.1.10. JVM Memory</h4>',21),_=e("table",null,[e("thead",null,[e("tr",null,[e("th",null,"Metric"),e("th",null,"Tags"),e("th",null,"Type"),e("th",null,"Description")])]),e("tbody",null,[e("tr",null,[e("td",null,"jvm_buffer_memory_used_bytes"),e("td",null,'id="direct/mapped"'),e("td",null,"AutoGauge"),e("td",null,"The used size of buffer")]),e("tr",null,[e("td",null,"jvm_buffer_total_capacity_bytes"),e("td",null,'id="direct/mapped"'),e("td",null,"AutoGauge"),e("td",null,"The max size of buffer")]),e("tr",null,[e("td",null,"jvm_buffer_count_buffers"),e("td",null,'id="direct/mapped"'),e("td",null,"AutoGauge"),e("td",null,"The number of buffer")]),e("tr",null,[e("td",null,"jvm_memory_committed_bytes"),e("td",{area:'heap/nonheap,id="xxx",'}),e("td",null,"AutoGauge"),e("td",null,"The committed memory of JVM")]),e("tr",null,[e("td",null,"jvm_memory_max_bytes"),e("td",{area:'heap/nonheap,id="xxx",'}),e("td",null,"AutoGauge"),e("td",null,"The max memory of JVM")]),e("tr",null,[e("td",null,"jvm_memory_used_bytes"),e("td",{area:'heap/nonheap,id="xxx",'}),e("td",null,"AutoGauge"),e("td",null,"The used memory of JVM")])])],-1),b=a('<h4 id="_4-1-11-jvm-thread" tabindex="-1"><a class="header-anchor" href="#_4-1-11-jvm-thread" aria-hidden="true">#</a> 4.1.11. JVM Thread</h4><table><thead><tr><th>Metric</th><th>Tags</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>jvm_threads_live_threads</td><td></td><td>AutoGauge</td><td>The number of live thread</td></tr><tr><td>jvm_threads_daemon_threads</td><td></td><td>AutoGauge</td><td>The number of daemon thread</td></tr><tr><td>jvm_threads_peak_threads</td><td></td><td>AutoGauge</td><td>The number of peak thread</td></tr><tr><td>jvm_threads_states_threads</td><td>state=&quot;runnable/blocked/waiting/timed-waiting/new/terminated&quot;</td><td>AutoGauge</td><td>The number of thread in different states</td></tr></tbody></table><h4 id="_4-1-12-jvm-gc" tabindex="-1"><a class="header-anchor" href="#_4-1-12-jvm-gc" aria-hidden="true">#</a> 4.1.12. JVM GC</h4><table><thead><tr><th>Metric</th><th>Tags</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>jvm_gc_pause</td><td>action=&quot;end of major GC/end of minor GC&quot;,cause=&quot;xxxx&quot;</td><td>Timer</td><td>The number and time consumed of Young GC/Full Gc caused by different reason</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>jvm_gc_concurrent_phase_time</td><td>action=&quot;{action}&quot;,cause=&quot;{cause}&quot;</td><td>Timer</td><td>The number and time consumed of Young GC/Full Gc caused by different</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>jvm_gc_max_data_size_bytes</td><td></td><td>AutoGauge</td><td>The historical maximum value of old memory</td></tr><tr><td>jvm_gc_live_data_size_bytes</td><td></td><td>AutoGauge</td><td>The usage of old memory</td></tr><tr><td>jvm_gc_memory_promoted_bytes</td><td></td><td>Counter</td><td>The accumulative value of positive memory growth of old memory</td></tr><tr><td>jvm_gc_memory_allocated_bytes</td><td></td><td>Counter</td><td>The accumulative value of positive memory growth of allocated memory</td></tr></tbody></table><h3 id="_4-2-important-level-metrics" tabindex="-1"><a class="header-anchor" href="#_4-2-important-level-metrics" aria-hidden="true">#</a> 4.2. Important level metrics</h3><h4 id="_4-2-1-node" tabindex="-1"><a class="header-anchor" href="#_4-2-1-node" aria-hidden="true">#</a> 4.2.1. Node</h4><table><thead><tr><th>Metric</th><th>Tags</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>region</td><td>name=&quot;total&quot;,type=&quot;SchemaRegion&quot;</td><td>AutoGauge</td><td>The total number of SchemaRegion in PartitionTable</td></tr><tr><td>region</td><td>name=&quot;total&quot;,type=&quot;DataRegion&quot;</td><td>AutoGauge</td><td>The total number of DataRegion in PartitionTable</td></tr><tr><td>region</td><td>name=&quot;{ip}:{port}&quot;,type=&quot;SchemaRegion&quot;</td><td>Gauge</td><td>The number of SchemaRegion in PartitionTable of specific node</td></tr><tr><td>region</td><td>name=&quot;{ip}:{port}&quot;,type=&quot;DataRegion&quot;</td><td>Gauge</td><td>The number of DataRegion in PartitionTable of specific node</td></tr></tbody></table><h4 id="_4-2-2-iotconsensus" tabindex="-1"><a class="header-anchor" href="#_4-2-2-iotconsensus" aria-hidden="true">#</a> 4.2.2. IoTConsensus</h4><table><thead><tr><th>Metric</th><th>Tags</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>mutli_leader</td><td>name=&quot;logDispatcher-{IP}:{Port}&quot;, region=&quot;{region}&quot;, type=&quot;currentSyncIndex&quot;</td><td>AutoGauge</td><td>The sync index of synchronization thread in replica group</td></tr><tr><td>mutli_leader</td><td>name=&quot;logDispatcher-{IP}:{Port}&quot;, region=&quot;{region}&quot;, type=&quot;cachedRequestInMemoryQueue&quot;</td><td>AutoGauge</td><td>The size of cache requests of synchronization thread in replica group</td></tr><tr><td>mutli_leader</td><td>name=&quot;IoTConsensusServerImpl&quot;, region=&quot;{region}&quot;, type=&quot;searchIndex&quot;</td><td>AutoGauge</td><td>The write process of main process in replica group</td></tr><tr><td>mutli_leader</td><td>name=&quot;IoTConsensusServerImpl&quot;, region=&quot;{region}&quot;, type=&quot;safeIndex&quot;</td><td>AutoGauge</td><td>The sync index of replica group</td></tr><tr><td>mutli_leader</td><td>name=&quot;IoTConsensusServerImpl&quot;, region=&quot;{region}&quot;, type=&quot;syncLag&quot;</td><td>AutoGauge</td><td>The sync lag of replica group</td></tr><tr><td>mutli_leader</td><td>name=&quot;IoTConsensusServerImpl&quot;, region=&quot;{region}&quot;, type=&quot;LogEntriesFromWAL&quot;</td><td>AutoGauge</td><td>The number of logEntries from wal in Batch</td></tr><tr><td>mutli_leader</td><td>name=&quot;IoTConsensusServerImpl&quot;, region=&quot;{region}&quot;, type=&quot;LogEntriesFromQueue&quot;</td><td>AutoGauge</td><td>The number of logEntries from queue in Batch</td></tr><tr><td>stage</td><td>name=&quot;iot_consensus&quot;, region=&quot;{region}&quot;, type=&quot;getStateMachineLock&quot;</td><td>Histogram</td><td>The time consumed to get statemachine lock in main process</td></tr><tr><td>stage</td><td>name=&quot;iot_consensus&quot;, region=&quot;{region}&quot;, type=&quot;checkingBeforeWrite&quot;</td><td>Histogram</td><td>The time consumed to precheck before write in main process</td></tr><tr><td>stage</td><td>name=&quot;iot_consensus&quot;, region=&quot;{region}&quot;, type=&quot;writeStateMachine&quot;</td><td>Histogram</td><td>The time consumed to write statemachine in main process</td></tr><tr><td>stage</td><td>name=&quot;iot_consensus&quot;, region=&quot;{region}&quot;, type=&quot;offerRequestToQueue&quot;</td><td>Histogram</td><td>The time consumed to try to offer request to queue in main process</td></tr><tr><td>stage</td><td>name=&quot;iot_consensus&quot;, region=&quot;{region}&quot;, type=&quot;consensusWrite&quot;</td><td>Histogram</td><td>The time consumed to the whole write in main process</td></tr><tr><td>stage</td><td>name=&quot;iot_consensus&quot;, region=&quot;{region}&quot;, type=&quot;constructBatch&quot;</td><td>Histogram</td><td>The time consumed to construct batch in synchronization thread</td></tr><tr><td>stage</td><td>name=&quot;iot_consensus&quot;, region=&quot;{region}&quot;, type=&quot;syncLogTimePerRequest&quot;</td><td>Histogram</td><td>The time consumed to sync log in asynchronous callback process</td></tr></tbody></table><h4 id="_4-2-3-cache" tabindex="-1"><a class="header-anchor" href="#_4-2-3-cache" aria-hidden="true">#</a> 4.2.3. Cache</h4><table><thead><tr><th>Metric</th><th>Tags</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>cache_hit</td><td>name=&quot;chunk&quot;</td><td>AutoGauge</td><td>The cache hit ratio of ChunkCache, Unit: %</td></tr><tr><td>cache_hit</td><td>name=&quot;schema&quot;</td><td>AutoGauge</td><td>The cache hit ratio of SchemaCache, Unit: %</td></tr><tr><td>cache_hit</td><td>name=&quot;timeSeriesMeta&quot;</td><td>AutoGauge</td><td>The cache hit ratio of TimeseriesMetadataCache, Unit: %</td></tr><tr><td>cache_hit</td><td>name=&quot;bloomFilter&quot;</td><td>AutoGauge</td><td>The interception rate of bloomFilter in TimeseriesMetadataCache, Unit: %</td></tr><tr><td>cache</td><td>name=&quot;Database&quot;, type=&quot;hit&quot;</td><td>Counter</td><td>The hit number of Database Cache</td></tr><tr><td>cache</td><td>name=&quot;Database&quot;, type=&quot;all&quot;</td><td>Counter</td><td>The access number of Database Cache</td></tr><tr><td>cache</td><td>name=&quot;SchemaPartition&quot;, type=&quot;hit&quot;</td><td>Counter</td><td>The hit number of SchemaPartition Cache</td></tr><tr><td>cache</td><td>name=&quot;SchemaPartition&quot;, type=&quot;all&quot;</td><td>Counter</td><td>The access number of SSchemaPartition Cache</td></tr><tr><td>cache</td><td>name=&quot;DataPartition&quot;, type=&quot;hit&quot;</td><td>Counter</td><td>The hit number of DataPartition Cache</td></tr><tr><td>cache</td><td>name=&quot;DataPartition&quot;, type=&quot;all&quot;</td><td>Counter</td><td>The access number of SDataPartition Cache</td></tr></tbody></table><h4 id="_4-2-4-memory" tabindex="-1"><a class="header-anchor" href="#_4-2-4-memory" aria-hidden="true">#</a> 4.2.4. Memory</h4><table><thead><tr><th>Metric</th><th>Tags</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>mem</td><td>name=&quot;database_{name}&quot;</td><td>AutoGauge</td><td>The memory usage of DataRegion in DataNode, Unit: byte</td></tr><tr><td>mem</td><td>name=&quot;chunkMetaData_{name}&quot;</td><td>AutoGauge</td><td>The memory usage of chunkMetaData when writting TsFile, Unit: byte</td></tr><tr><td>mem</td><td>name=&quot;IoTConsensus&quot;</td><td>AutoGauge</td><td>The memory usage of IoTConsensus, Unit: byte</td></tr><tr><td>mem</td><td>name=&quot;IoTConsensusQueue&quot;</td><td>AutoGauge</td><td>The memory usage of IoTConsensus Queue, Unit: byte</td></tr><tr><td>mem</td><td>name=&quot;IoTConsensusSync&quot;</td><td>AutoGauge</td><td>The memory usage of IoTConsensus SyncStatus, Unit: byte</td></tr><tr><td>mem</td><td>name=&quot;schema_region_total_usage&quot;</td><td>AutoGauge</td><td>The memory usage of all SchemaRegion, Unit: byte</td></tr></tbody></table><h4 id="_4-2-5-compaction" tabindex="-1"><a class="header-anchor" href="#_4-2-5-compaction" aria-hidden="true">#</a> 4.2.5. Compaction</h4><table><thead><tr><th>Metric</th><th>Tags</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>data_written</td><td>name=&quot;compaction&quot;, type=&quot;aligned/not-aligned/total&quot;</td><td>Counter</td><td>The written size of compaction</td></tr><tr><td>data_read</td><td>name=&quot;compaction&quot;</td><td>Counter</td><td>The read size of compaction</td></tr><tr><td>compaction_task_count</td><td>name = &quot;inner_compaction&quot;, type=&quot;sequence&quot;</td><td>Counter</td><td>The number of inner sequence compction</td></tr><tr><td>compaction_task_count</td><td>name = &quot;inner_compaction&quot;, type=&quot;unsequence&quot;</td><td>Counter</td><td>The number of inner sequence compction</td></tr><tr><td>compaction_task_count</td><td>name = &quot;cross_compaction&quot;, type=&quot;cross&quot;</td><td>Counter</td><td>The number of corss compction</td></tr></tbody></table><h4 id="_4-2-6-iotdb-process" tabindex="-1"><a class="header-anchor" href="#_4-2-6-iotdb-process" aria-hidden="true">#</a> 4.2.6. IoTDB Process</h4><table><thead><tr><th>Metric</th><th>Tags</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>process_used_mem</td><td>name=&quot;memory&quot;</td><td>AutoGauge</td><td>The used memory of IoTDB process</td></tr><tr><td>process_mem_ratio</td><td>name=&quot;memory&quot;</td><td>AutoGauge</td><td>The used memory ratio of IoTDB process</td></tr><tr><td>process_threads_count</td><td>name=&quot;process&quot;</td><td>AutoGauge</td><td>The number of thread of IoTDB process</td></tr><tr><td>process_status</td><td>name=&quot;process&quot;</td><td>AutoGauge</td><td>The status of IoTDB process, 1=live, 0=dead</td></tr></tbody></table><h4 id="_4-2-7-jvm-class" tabindex="-1"><a class="header-anchor" href="#_4-2-7-jvm-class" aria-hidden="true">#</a> 4.2.7. JVM Class</h4><table><thead><tr><th>Metric</th><th>Tags</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>jvm_classes_unloaded_classes</td><td></td><td>AutoGauge</td><td>The number of unloaded class</td></tr><tr><td>jvm_classes_loaded_classes</td><td></td><td>AutoGauge</td><td>The number of loaded class</td></tr></tbody></table><h4 id="_4-2-8-jvm-compilation" tabindex="-1"><a class="header-anchor" href="#_4-2-8-jvm-compilation" aria-hidden="true">#</a> 4.2.8. JVM Compilation</h4>',20),T=e("table",null,[e("thead",null,[e("tr",null,[e("th",null,"Metric"),e("th",null,"Tags"),e("th",null,"Type"),e("th",null,"Description")])]),e("tbody",null,[e("tr",null,[e("td",null,"jvm_compilation_time_ms"),e("td",{compiler:"HotSpot 64-Bit Tiered Compilers,"}),e("td",null,"AutoGauge"),e("td",null,"The time consumed in compilation")])])],-1),v=a('<h4 id="_4-2-9-query-planning" tabindex="-1"><a class="header-anchor" href="#_4-2-9-query-planning" aria-hidden="true">#</a> 4.2.9. Query Planning</h4><table><thead><tr><th>Metric</th><th>Tags</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>query_plan_cost</td><td>stage=&quot;analyzer&quot;</td><td>Timer</td><td>The query statement analysis time-consuming</td></tr><tr><td>query_plan_cost</td><td>stage=&quot;logical_planner&quot;</td><td>Timer</td><td>The query logical plan planning time-consuming</td></tr><tr><td>query_plan_cost</td><td>stage=&quot;distribution_planner&quot;</td><td>Timer</td><td>The query distribution plan planning time-consuming</td></tr><tr><td>query_plan_cost</td><td>stage=&quot;partition_fetcher&quot;</td><td>Timer</td><td>The partition information fetching time-consuming</td></tr><tr><td>query_plan_cost</td><td>stage=&quot;schema_fetcher&quot;</td><td>Timer</td><td>The schema information fetching time-consuming</td></tr></tbody></table><h4 id="_4-2-10-plan-dispatcher" tabindex="-1"><a class="header-anchor" href="#_4-2-10-plan-dispatcher" aria-hidden="true">#</a> 4.2.10. Plan Dispatcher</h4><table><thead><tr><th>Metric</th><th>Tags</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>dispatcher</td><td>stage=&quot;wait_for_dispatch&quot;</td><td>Timer</td><td>The distribution plan dispatcher time-consuming</td></tr><tr><td>dispatcher</td><td>stage=&quot;dispatch_read&quot;</td><td>Timer</td><td>The distribution plan dispatcher time-consuming (only query)</td></tr></tbody></table><h4 id="_4-2-11-query-resource" tabindex="-1"><a class="header-anchor" href="#_4-2-11-query-resource" aria-hidden="true">#</a> 4.2.11. Query Resource</h4><table><thead><tr><th>Metric</th><th>Tags</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>query_resource</td><td>type=&quot;sequence_tsfile&quot;</td><td>Rate</td><td>The access frequency of sequence tsfiles</td></tr><tr><td>query_resource</td><td>type=&quot;unsequence_tsfile&quot;</td><td>Rate</td><td>The access frequency of unsequence tsfiles</td></tr><tr><td>query_resource</td><td>type=&quot;flushing_memtable&quot;</td><td>Rate</td><td>The access frequency of flushing memtables</td></tr><tr><td>query_resource</td><td>type=&quot;working_memtable&quot;</td><td>Rate</td><td>The access frequency of working memtables</td></tr></tbody></table><h4 id="_4-2-12-data-exchange" tabindex="-1"><a class="header-anchor" href="#_4-2-12-data-exchange" aria-hidden="true">#</a> 4.2.12. Data Exchange</h4><table><thead><tr><th>Metric</th><th>Tags</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>data_exchange_cost</td><td>operation=&quot;source_handle_get_tsblock&quot;, type=&quot;local/remote&quot;</td><td>Timer</td><td>The time-consuming that source handles receive TsBlock</td></tr><tr><td>data_exchange_cost</td><td>operation=&quot;source_handle_deserialize_tsblock&quot;, type=&quot;local/remote&quot;</td><td>Timer</td><td>The time-consuming that source handles deserialize TsBlock</td></tr><tr><td>data_exchange_cost</td><td>operation=&quot;sink_handle_send_tsblock&quot;, type=&quot;local/remote&quot;</td><td>Timer</td><td>The time-consuming that sink handles send TsBlock</td></tr><tr><td>data_exchange_cost</td><td>operation=&quot;send_new_data_block_event_task&quot;, type=&quot;server/caller&quot;</td><td>Timer</td><td>The RPC time-consuming that sink handles send TsBlock</td></tr><tr><td>data_exchange_cost</td><td>operation=&quot;get_data_block_task&quot;, type=&quot;server/caller&quot;</td><td>Timer</td><td>The RPC time-consuming that source handles receive TsBlock</td></tr><tr><td>data_exchange_cost</td><td>operation=&quot;on_acknowledge_data_block_event_task&quot;, type=&quot;server/caller&quot;</td><td>Timer</td><td>The RPC time-consuming that source handles ack received TsBlock</td></tr><tr><td>data_exchange_count</td><td>name=&quot;send_new_data_block_num&quot;, type=&quot;server/caller&quot;</td><td>Histogram</td><td>The number of sent TsBlocks by sink handles</td></tr><tr><td>data_exchange_count</td><td>name=&quot;get_data_block_num&quot;, type=&quot;server/caller&quot;</td><td>Histogram</td><td>The number of received TsBlocks by source handles</td></tr><tr><td>data_exchange_count</td><td>name=&quot;on_acknowledge_data_block_num&quot;, type=&quot;server/caller&quot;</td><td>Histogram</td><td>The number of acknowledged TsBlocks by source handles</td></tr></tbody></table><h4 id="_4-2-13-query-task-schedule" tabindex="-1"><a class="header-anchor" href="#_4-2-13-query-task-schedule" aria-hidden="true">#</a> 4.2.13. Query Task Schedule</h4><table><thead><tr><th>Metric</th><th>Tags</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>driver_scheduler</td><td>name=&quot;ready_queued_time&quot;</td><td>Timer</td><td>The queuing time of ready queue</td></tr><tr><td>driver_scheduler</td><td>name=&quot;block_queued_time&quot;</td><td>Timer</td><td>The queuing time of blocking queue</td></tr><tr><td>driver_scheduler</td><td>name=&quot;ready_queue_task_count&quot;</td><td>AutoGauge</td><td>The number of tasks queued in the ready queue</td></tr><tr><td>driver_scheduler</td><td>name=&quot;block_queued_task_count&quot;</td><td>AutoGauge</td><td>The number of tasks queued in the blocking queue</td></tr></tbody></table><h4 id="_4-2-14-query-execution" tabindex="-1"><a class="header-anchor" href="#_4-2-14-query-execution" aria-hidden="true">#</a> 4.2.14. Query Execution</h4><table><thead><tr><th>Metric</th><th>Tags</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>query_execution</td><td>stage=&quot;local_execution_planner&quot;</td><td>Timer</td><td>The time-consuming of operator tree construction</td></tr><tr><td>query_execution</td><td>stage=&quot;query_resource_init&quot;</td><td>Timer</td><td>The time-consuming of query resource initialization</td></tr><tr><td>query_execution</td><td>stage=&quot;get_query_resource_from_mem&quot;</td><td>Timer</td><td>The time-consuming of query resource memory query and construction</td></tr><tr><td>query_execution</td><td>stage=&quot;driver_internal_process&quot;</td><td>Timer</td><td>The time-consuming of driver execution</td></tr><tr><td>query_execution</td><td>stage=&quot;wait_for_result&quot;</td><td>Timer</td><td>The time-consuming of getting query result from result handle</td></tr><tr><td>operator_execution_cost</td><td>name=&quot;{operator_name}&quot;</td><td>Timer</td><td>The operator execution time</td></tr><tr><td>operator_execution_count</td><td>name=&quot;{operator_name}&quot;</td><td>Counter</td><td>The number of operator calls (counted by the number of next method calls)</td></tr><tr><td>aggregation</td><td>from=&quot;raw_data&quot;</td><td>Timer</td><td>The time-consuming of performing an aggregation calculation from a batch of raw data</td></tr><tr><td>aggregation</td><td>from=&quot;statistics&quot;</td><td>Timer</td><td>The time-consuming of updating an aggregated value with statistics</td></tr><tr><td>series_scan_cost</td><td>stage=&quot;load_timeseries_metadata&quot;, type=&quot;aligned/non_aligned&quot;, from=&quot;mem/disk&quot;</td><td>Timer</td><td>The time-consuming of loading TimeseriesMetadata</td></tr><tr><td>series_scan_cost</td><td>stage=&quot;read_timeseries_metadata&quot;, type=&quot;&quot;, from=&quot;cache/file&quot;</td><td>Timer</td><td>The time-consuming of reading TimeseriesMetadata of a tsfile</td></tr><tr><td>series_scan_cost</td><td>stage=&quot;timeseries_metadata_modification&quot;, type=&quot;aligned/non_aligned&quot;, from=&quot;null&quot;</td><td>Timer</td><td>The time-consuming of filtering TimeseriesMetadata by mods</td></tr><tr><td>series_scan_cost</td><td>stage=&quot;load_chunk_metadata_list&quot;, type=&quot;aligned/non_aligned&quot;, from=&quot;mem/disk&quot;</td><td>Timer</td><td>The time-consuming of loading ChunkMetadata list</td></tr><tr><td>series_scan_cost</td><td>stage=&quot;chunk_metadata_modification&quot;, type=&quot;aligned/non_aligned&quot;, from=&quot;mem/disk&quot;</td><td>Timer</td><td>The time-consuming of filtering ChunkMetadata by mods</td></tr><tr><td>series_scan_cost</td><td>stage=&quot;chunk_metadata_filter&quot;, type=&quot;aligned/non_aligned&quot;, from=&quot;mem/disk&quot;</td><td>Timer</td><td>The time-consuming of filtering ChunkMetadata by query filter</td></tr><tr><td>series_scan_cost</td><td>stage=&quot;construct_chunk_reader&quot;, type=&quot;aligned/non_aligned&quot;, from=&quot;mem/disk&quot;</td><td>Timer</td><td>The time-consuming of constructing ChunkReader</td></tr><tr><td>series_scan_cost</td><td>stage=&quot;read_chunk&quot;, type=&quot;&quot;, from=&quot;cache/file&quot;</td><td>Timer</td><td>The time-consuming of reading Chunk</td></tr><tr><td>series_scan_cost</td><td>stage=&quot;init_chunk_reader&quot;, type=&quot;aligned/non_aligned&quot;, from=&quot;mem/disk&quot;</td><td>Timer</td><td>The time-consuming of initializing ChunkReader (constructing PageReader)</td></tr><tr><td>series_scan_cost</td><td>stage=&quot;build_tsblock_from_page_reader&quot;, type=&quot;aligned/non_aligned&quot;, from=&quot;mem/disk&quot;</td><td>Timer</td><td>The time-consuming of constructing Tsblock from PageReader</td></tr><tr><td>series_scan_cost</td><td>stage=&quot;build_tsblock_from_merge_reader&quot;, type=&quot;aligned/non_aligned&quot;, from=&quot;null&quot;</td><td>Timer</td><td>The time-consuming of constructing Tsblock from MergeReader (handling overlapping data)</td></tr></tbody></table><h4 id="_4-2-16-schema-engine" tabindex="-1"><a class="header-anchor" href="#_4-2-16-schema-engine" aria-hidden="true">#</a> 4.2.16 Schema Engine</h4><table><thead><tr><th>Metric</th><th>Tags</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>schema_engine</td><td>name=&quot;schema_region_total_mem_usage&quot;</td><td>AutoGauge</td><td>Memory usgae for all SchemaRegion</td></tr><tr><td>schema_engine</td><td>name=&quot;schema_region_mem_capacity&quot;</td><td>AutoGauge</td><td>Memory capacity for all SchemaRegion</td></tr><tr><td>schema_engine</td><td>name=&quot;schema_engine_mode&quot;</td><td>Gauge</td><td>Mode of SchemaEngine</td></tr><tr><td>schema_engine</td><td>name=&quot;schema_region_consensus&quot;</td><td>Gauge</td><td>Consensus protocol of SchemaRegion</td></tr><tr><td>schema_engine</td><td>name=&quot;schema_region_number&quot;</td><td>AutoGauge</td><td>Number of SchemaRegion</td></tr><tr><td>schema_region</td><td>name=&quot;schema_region_mem_usage&quot;, region=&quot;SchemaRegion[{regionId}]&quot;</td><td>AutoGauge</td><td>Memory usgae for each SchemaRegion</td></tr><tr><td>schema_region</td><td>name=&quot;schema_region_series_cnt&quot;, region=&quot;SchemaRegion[{regionId}]&quot;</td><td>AutoGauge</td><td>Timeseries count for each SchemaRegion</td></tr></tbody></table><h3 id="_4-3-normal-level-metrics" tabindex="-1"><a class="header-anchor" href="#_4-3-normal-level-metrics" aria-hidden="true">#</a> 4.3. Normal level Metrics</h3><h4 id="_4-3-1-cluster" tabindex="-1"><a class="header-anchor" href="#_4-3-1-cluster" aria-hidden="true">#</a> 4.3.1. Cluster</h4><table><thead><tr><th>Metric</th><th>Tags</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>region</td><td>name=&quot;{DatabaseName}&quot;,type=&quot;SchemaRegion/DataRegion&quot;</td><td>AutoGauge</td><td>The number of DataRegion/SchemaRegion of database in specific node</td></tr><tr><td>slot</td><td>name=&quot;{DatabaseName}&quot;,type=&quot;schemaSlotNumber/dataSlotNumber&quot;</td><td>AutoGauge</td><td>The number of DataSlot/SchemaSlot of database in specific node</td></tr></tbody></table><h3 id="_4-4-all-metric" tabindex="-1"><a class="header-anchor" href="#_4-4-all-metric" aria-hidden="true">#</a> 4.4. All Metric</h3><p>Currently there is no All level metrics, and it will continue to be added in the future.</p><h2 id="_5-how-to-get-these-metrics" tabindex="-1"><a class="header-anchor" href="#_5-how-to-get-these-metrics" aria-hidden="true">#</a> 5. How to get these metrics？</h2><p>The relevant configuration of the metric module is in <code>conf/iotdb-{datanode/confignode}.properties</code>, and all configuration items support hot loading through the <code>load configuration</code> command.</p><h3 id="_5-1-jmx" tabindex="-1"><a class="header-anchor" href="#_5-1-jmx" aria-hidden="true">#</a> 5.1. JMX</h3><p>For metrics exposed externally using JMX, you can view them through Jconsole. After entering the Jconsole monitoring page, you will first see an overview of various running conditions of IoTDB. Here you can see heap memory information, thread information, class information, and the server&#39;s CPU usage.</p><h4 id="_5-1-1-obtain-metric-data" tabindex="-1"><a class="header-anchor" href="#_5-1-1-obtain-metric-data" aria-hidden="true">#</a> 5.1.1. Obtain metric data</h4><p>After connecting to JMX, you can find the &quot;MBean&quot; named &quot;org.apache.iotdb.metrics&quot; through the &quot;MBeans&quot; tab, and you can view the specific values of all monitoring metrics in the sidebar.</p><img style="width:100%;max-width:800px;max-height:600px;margin-left:auto;margin-right:auto;display:block;" alt="metric-jmx" src="'+n+'"><h4 id="_5-1-2-get-other-relevant-data" tabindex="-1"><a class="header-anchor" href="#_5-1-2-get-other-relevant-data" aria-hidden="true">#</a> 5.1.2. Get other relevant data</h4><p>After connecting to JMX, you can find the &quot;MBean&quot; named &quot;org.apache.iotdb.service&quot; through the &quot;MBeans&quot; tab, as shown in the image below, to understand the basic status of the service</p><p><img style="width:100%;max-width:800px;max-height:600px;margin-left:auto;margin-right:auto;display:block;" src="'+r+'"> <br></p><p>In order to improve query performance, IOTDB caches ChunkMetaData and TsFileMetaData. Users can use MXBean and expand the sidebar <code>org.apache.iotdb.db.service</code> to view the cache hit ratio:</p><img style="width:100%;max-width:800px;max-height:600px;margin-left:auto;margin-right:auto;display:block;" src="'+i+`"><h3 id="_5-2-prometheus" tabindex="-1"><a class="header-anchor" href="#_5-2-prometheus" aria-hidden="true">#</a> 5.2. Prometheus</h3><h4 id="_5-2-1-the-mapping-from-metric-type-to-prometheus-format" tabindex="-1"><a class="header-anchor" href="#_5-2-1-the-mapping-from-metric-type-to-prometheus-format" aria-hidden="true">#</a> 5.2.1. The mapping from metric type to prometheus format</h4><blockquote><p>For metrics whose Metric Name is name and Tags are K1=V1, ..., Kn=Vn, the mapping is as follows, where value is a specific value</p></blockquote><table><thead><tr><th>Metric Type</th><th>Mapping</th></tr></thead><tbody><tr><td>Counter</td><td>name_total{cluster=&quot;clusterName&quot;, nodeType=&quot;nodeType&quot;, nodeId=&quot;nodeId&quot;, k1=&quot;V1&quot;, ..., Kn=&quot;Vn&quot;} value</td></tr><tr><td>AutoGauge、Gauge</td><td>name{cluster=&quot;clusterName&quot;, nodeType=&quot;nodeType&quot;, nodeId=&quot;nodeId&quot;, k1=&quot;V1&quot;, ..., Kn=&quot;Vn&quot;} value</td></tr><tr><td>Histogram</td><td>name_max{cluster=&quot;clusterName&quot;, nodeType=&quot;nodeType&quot;, nodeId=&quot;nodeId&quot;, k1=&quot;V1&quot;, ..., Kn=&quot;Vn&quot;} value <br> name_sum{cluster=&quot;clusterName&quot;, nodeType=&quot;nodeType&quot;, nodeId=&quot;nodeId&quot;, k1=&quot;V1&quot;, ..., Kn=&quot;Vn&quot;} value <br> name_count{cluster=&quot;clusterName&quot;, nodeType=&quot;nodeType&quot;, nodeId=&quot;nodeId&quot;, k1=&quot;V1&quot;, ..., Kn=&quot;Vn&quot;} value <br> name{cluster=&quot;clusterName&quot;, nodeType=&quot;nodeType&quot;, nodeId=&quot;nodeId&quot;, k1=&quot;V1&quot;, ..., Kn=&quot;Vn&quot;, quantile=&quot;0.0&quot;} value <br> name{cluster=&quot;clusterName&quot;, nodeType=&quot;nodeType&quot;, nodeId=&quot;nodeId&quot;, k1=&quot;V1&quot;, ..., Kn=&quot;Vn&quot;, quantile=&quot;0.5&quot;} value <br> name{cluster=&quot;clusterName&quot;, nodeType=&quot;nodeType&quot;, nodeId=&quot;nodeId&quot;, k1=&quot;V1&quot;, ..., Kn=&quot;Vn&quot;, quantile=&quot;0.75&quot;} value <br> name{cluster=&quot;clusterName&quot;, nodeType=&quot;nodeType&quot;, nodeId=&quot;nodeId&quot;, k1=&quot;V1&quot;, ..., Kn=&quot;Vn&quot;, quantile=&quot;0.99&quot;} value <br> name{cluster=&quot;clusterName&quot;, nodeType=&quot;nodeType&quot;, nodeId=&quot;nodeId&quot;, k1=&quot;V1&quot;, ..., Kn=&quot;Vn&quot;, quantile=&quot;0.999&quot;} value</td></tr><tr><td>Rate</td><td>name_total{cluster=&quot;clusterName&quot;, nodeType=&quot;nodeType&quot;, nodeId=&quot;nodeId&quot;, k1=&quot;V1&quot;, ..., Kn=&quot;Vn&quot;} value <br> name_total{cluster=&quot;clusterName&quot;, nodeType=&quot;nodeType&quot;, nodeId=&quot;nodeId&quot;, k1=&quot;V1&quot;, ..., Kn=&quot;Vn&quot;, rate=&quot;m1&quot;} value <br> name_total{cluster=&quot;clusterName&quot;, nodeType=&quot;nodeType&quot;, nodeId=&quot;nodeId&quot;, k1=&quot;V1&quot;, ..., Kn=&quot;Vn&quot;, rate=&quot;m5&quot;} value <br> name_total{cluster=&quot;clusterName&quot;, nodeType=&quot;nodeType&quot;, nodeId=&quot;nodeId&quot;, k1=&quot;V1&quot;, ..., Kn=&quot;Vn&quot;, rate=&quot;m15&quot;} value <br> name_total{cluster=&quot;clusterName&quot;, nodeType=&quot;nodeType&quot;, nodeId=&quot;nodeId&quot;, k1=&quot;V1&quot;, ..., Kn=&quot;Vn&quot;, rate=&quot;mean&quot;} value</td></tr><tr><td>Timer</td><td>name_seconds_max{cluster=&quot;clusterName&quot;, nodeType=&quot;nodeType&quot;, nodeId=&quot;nodeId&quot;, k1=&quot;V1&quot;, ..., Kn=&quot;Vn&quot;} value <br> name_seconds_sum{cluster=&quot;clusterName&quot;, nodeType=&quot;nodeType&quot;, nodeId=&quot;nodeId&quot;, k1=&quot;V1&quot;, ..., Kn=&quot;Vn&quot;} value <br> name_seconds_count{cluster=&quot;clusterName&quot;, nodeType=&quot;nodeType&quot;, nodeId=&quot;nodeId&quot;, k1=&quot;V1&quot;, ..., Kn=&quot;Vn&quot;} value <br> name_seconds{cluster=&quot;clusterName&quot;, nodeType=&quot;nodeType&quot;, nodeId=&quot;nodeId&quot;, k1=&quot;V1&quot;, ..., Kn=&quot;Vn&quot;, quantile=&quot;0.0&quot;} value <br> name_seconds{cluster=&quot;clusterName&quot;, nodeType=&quot;nodeType&quot;, nodeId=&quot;nodeId&quot;, k1=&quot;V1&quot;, ..., Kn=&quot;Vn&quot;, quantile=&quot;0.5&quot;} value <br> name_seconds{cluster=&quot;clusterName&quot;, nodeType=&quot;nodeType&quot;, nodeId=&quot;nodeId&quot;, k1=&quot;V1&quot;, ..., Kn=&quot;Vn&quot;, quantile=&quot;0.75&quot;} value <br> name_seconds{cluster=&quot;clusterName&quot;, nodeType=&quot;nodeType&quot;, nodeId=&quot;nodeId&quot;, k1=&quot;V1&quot;, ..., Kn=&quot;Vn&quot;, quantile=&quot;0.99&quot;} value <br> name_seconds{cluster=&quot;clusterName&quot;, nodeType=&quot;nodeType&quot;, nodeId=&quot;nodeId&quot;, k1=&quot;V1&quot;, ..., Kn=&quot;Vn&quot;, quantile=&quot;0.999&quot;} value</td></tr></tbody></table><h4 id="_5-2-2-config-file" tabindex="-1"><a class="header-anchor" href="#_5-2-2-config-file" aria-hidden="true">#</a> 5.2.2. Config File</h4><ol><li>Taking DataNode as an example, modify the iotdb-datanode.properties configuration file as follows:</li></ol><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token key attr-name">dn_metric_reporter_list</span><span class="token punctuation">=</span><span class="token value attr-value">PROMETHEUS</span>
<span class="token key attr-name">dn_metric_level</span><span class="token punctuation">=</span><span class="token value attr-value">CORE</span>
<span class="token key attr-name">dn_metric_prometheus_reporter_port</span><span class="token punctuation">=</span><span class="token value attr-value">9091</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Then you can get metrics data as follows</p><ol start="2"><li>Start IoTDB DataNodes</li><li>Open a browser or use <code>curl</code> to visit <code>http://servier_ip:9091/metrics</code>, you can get the following metric data:</li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>...
# HELP file_count
# TYPE file_count gauge
file_count{name=&quot;wal&quot;,} 0.0
file_count{name=&quot;unseq&quot;,} 0.0
file_count{name=&quot;seq&quot;,} 2.0
...
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_5-2-3-prometheus-grafana" tabindex="-1"><a class="header-anchor" href="#_5-2-3-prometheus-grafana" aria-hidden="true">#</a> 5.2.3. Prometheus + Grafana</h4><p>As shown above, IoTDB exposes monitoring metrics data in the standard Prometheus format to the outside world. Prometheus can be used to collect and store monitoring indicators, and Grafana can be used to visualize monitoring indicators.</p><p>The following picture describes the relationships among IoTDB, Prometheus and Grafana</p><figure><img src="`+s+`" alt="iotdb_prometheus_grafana" tabindex="0" loading="lazy"><figcaption>iotdb_prometheus_grafana</figcaption></figure><ol><li>Along with running, IoTDB will collect its metrics continuously.</li><li>Prometheus scrapes metrics from IoTDB at a constant interval (can be configured).</li><li>Prometheus saves these metrics to its inner TSDB.</li><li>Grafana queries metrics from Prometheus at a constant interval (can be configured) and then presents them on the graph.</li></ol><p>So, we need to do some additional works to configure and deploy Prometheus and Grafana.</p><p>For instance, you can config your Prometheus as follows to get metrics data from IoTDB:</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">job_name</span><span class="token punctuation">:</span> pull<span class="token punctuation">-</span>metrics
<span class="token key atrule">honor_labels</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
<span class="token key atrule">honor_timestamps</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
<span class="token key atrule">scrape_interval</span><span class="token punctuation">:</span> 15s
<span class="token key atrule">scrape_timeout</span><span class="token punctuation">:</span> 10s
<span class="token key atrule">metrics_path</span><span class="token punctuation">:</span> /metrics
<span class="token key atrule">scheme</span><span class="token punctuation">:</span> http
<span class="token key atrule">follow_redirects</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
<span class="token key atrule">static_configs</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">targets</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> localhost<span class="token punctuation">:</span><span class="token number">9091</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The following documents may help you have a good journey with Prometheus and Grafana.</p>`,50),k={href:"https://prometheus.io/docs/prometheus/latest/getting_started/",target:"_blank",rel:"noopener noreferrer"},I={href:"https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scrape_config",target:"_blank",rel:"noopener noreferrer"},x={href:"https://grafana.com/docs/grafana/latest/getting-started/getting-started/",target:"_blank",rel:"noopener noreferrer"},w={href:"https://prometheus.io/docs/visualization/grafana/#grafana-support-for-prometheus",target:"_blank",rel:"noopener noreferrer"},C=a('<h4 id="_5-2-4-apache-iotdb-dashboard" tabindex="-1"><a class="header-anchor" href="#_5-2-4-apache-iotdb-dashboard" aria-hidden="true">#</a> 5.2.4. Apache IoTDB Dashboard</h4><p>We provide the Apache IoTDB Dashboard, and the rendering shown in Grafana is as follows:</p><figure><img src="'+u+'" alt="Apache IoTDB Dashboard" tabindex="0" loading="lazy"><figcaption>Apache IoTDB Dashboard</figcaption></figure><h5 id="_5-2-4-1-how-to-get-apache-iotdb-dashboard" tabindex="-1"><a class="header-anchor" href="#_5-2-4-1-how-to-get-apache-iotdb-dashboard" aria-hidden="true">#</a> 5.2.4.1. How to get Apache IoTDB Dashboard</h5>',4),P=e("li",null,[t("You can obtain the json files of Dashboards by GitHub: "),e("ol",null,[e("li",null,[e("a",{href:"https://github.com/apache/iotdb/tree/master/docs/UserGuide/Monitor-Alert/Apache-IoTDB-ConfigNode-Dashboard.json"}," Apache IoTDB ConfigNode Dashboard")]),e("li",null,[e("a",{href:"https://github.com/apache/iotdb/tree/master/docs/UserGuide/Monitor-Alert/Apache-IoTDB-DataNode-Dashboard.json"}," Apache IoTDB DataNode Dashboard")])])],-1),D={href:"https://grafana.com/grafana/dashboards/",target:"_blank",rel:"noopener noreferrer"},A=e("code",null,"Apache IoTDB Dashboard",-1),G=a('<p>When creating Grafana, you can select the json file you just downloaded to <code>Import</code> and select the corresponding target data source for Apache IoTDB Dashboard.</p><h5 id="_5-2-4-2-apache-iotdb-confignode-dashboard-instructions" tabindex="-1"><a class="header-anchor" href="#_5-2-4-2-apache-iotdb-confignode-dashboard-instructions" aria-hidden="true">#</a> 5.2.4.2. Apache IoTDB ConfigNode Dashboard Instructions</h5><blockquote><p>Except for the metrics specified specially, the following metrics are guaranteed to be available in the monitoring framework at the Important levels.</p></blockquote><ul><li><code>Overview</code>: system overview <ul><li><code>Registered Node</code>: The number of registered ConfigNode/DataNode</li><li><code>DataNode</code>(Only visible in the leader of ConfigNode): The status of the cluster DataNode, including Online and Unknown.</li><li><code>ConfigNode</code>(Only visible in the leader of ConfigNode): The status of the cluster ConfigNode, including Online and Unknown.</li><li><code>The Status Of Node</code>: The status of specific nodes in the cluster, including Online and Unknown.</li></ul></li><li><code>Region</code>: Region overview <ul><li><code>Region Number</code>: the number of Regions, including the total number, the number of DataRegions and the number of SchemaRegions.</li><li><code>Leadership distribution</code>: Cluster leader distribution, which refers to the number of Leaders corresponding to the Region on each node.</li><li><code>Total Region in Node</code>: The total number of Regions of different Nodes.</li><li><code>Region in Node</code>: the number of SchemaRegions/DataRegions of different Nodes.</li><li><code>Region in Database</code> (Normal level): the number of Regions in different Databases, including SchemaRegion and DataRegion.</li><li><code>Slot in Database</code> (Normal level): The number of Slots in different Databases, including the number of DataSlots and SchemaSlots.</li></ul></li><li><code>System</code>: system <ul><li><code>CPU Core</code>: the number of CPU cores in the system.</li><li><code>CPU Load</code>: system CPU load, progress CPU load.</li><li><code>CPU Time Per Minute</code>: The process takes up the system CPU time per minute on average. Note: multi-core will cause this value to exceed 1 minute.</li><li><code>System Memory</code>: the physical memory size of the system, the physical memory size used by the system, and the memory size submitted by the virtual machine.</li><li><code>System Swap Size</code>: the total size of the system swap area, the size used by the system swap area.</li><li><code>Process Memory</code>: the maximum total memory size of the IoTDB process, the total memory size of the IoTDB process, and the memory size used by the IoTDB process.</li><li><code>The Number of GC Per Minute</code>: The average number of GC per minute.</li><li><code>The Time Consumed Of GC Per Minute</code>: Average GC time spent per minute.</li><li><code>The Number Of Java Thread</code>: The number of threads in different states of the IoTDB process.</li><li><code>Heap Memory</code>: the heap memory of the IoTDB process</li><li><code>Off Heap Memory</code>: the off-heap memory of the IoTDB process</li><li><code>Log Number Per Minute</code>: the average number of logs per minute of the IoTDB process</li><li><code>The Time Consumed of Compliation Per Minute</code>: average compilation time per minute</li><li><code>The Number Of Class</code>: The number of classes loaded and unloaded by the JVM</li></ul></li></ul><h5 id="_5-2-4-3-apache-iotdb-datanode-dashboard-instructions" tabindex="-1"><a class="header-anchor" href="#_5-2-4-3-apache-iotdb-datanode-dashboard-instructions" aria-hidden="true">#</a> 5.2.4.3. Apache IoTDB DataNode Dashboard Instructions</h5><blockquote><p>Except for the metrics specified specially, the following metrics are guaranteed to be available in the monitoring framework at the Important levels.</p></blockquote><ul><li><code>Overview</code>: system overview <ul><li><code>The Number Of Entity</code>: the number of entities, including time series, etc.</li><li><code>Write Point Per Minute</code>: the average number of system write points per minute</li><li><code>Database Used Memory</code>: the memory size used by each Database</li></ul></li><li><code>Interface</code>: interface <ul><li><code>The Time Consumed Of Operation(50%)</code>: Median time spent by different client operations</li><li><code>The Time Consumed Of Operation(99%)</code>: The P99 of the time consumed by different client operations</li><li><code>The Time Consumed Of Operation(99.9%)</code>: The P999 time spent by different client operations</li><li><code>The OPS of Interface</code>: system interface visits per second</li><li><code>The Time Consumed Of Interface</code>: the average time consumed by the system interface</li><li><code>Cache Hit Rate</code>: cache hit rate</li><li><code>Thrift Connection</code>: the number of Thrift connections established</li><li><code>Thrift Active Thread</code>: The number of active Thrift connections established</li></ul></li><li><code>Query Engine</code>: query engine <ul><li><code>The time consumed of query plan stages(avg\\50%\\99%\\99.9%)</code>: The average\\median\\P99\\P999 value of the query plan stages time consumption</li><li><code>The time consumed of plan dispatch stages(avg\\50%\\99%\\99.9%)</code>: The average\\median\\P99\\P999 value of query plan dispatch stages time consumption</li><li><code>The time consumed of query execution stages(avg\\50%\\99%\\99.9%)</code>: the average\\median\\P99\\P999 value of the query execution stages time consumption</li><li><code>The time consumed of operator execution stages(avg\\50%\\99%\\99.9%)</code>: the average\\median\\P99\\P999 value of operator exection time consumption</li><li><code>The time consumed of query aggregation(avg\\50%\\99%\\99.9%)</code>: The average\\median\\P99\\P999 value of query aggregation time consumption</li><li><code>The time consumed of query scan(avg\\50%\\99%\\99.9%)</code>: the average\\median\\P99\\P999 value of query file/memory time consumption</li><li><code>The usage of query resource(avg\\50%\\99%\\99.9%)</code>: the average\\median\\P99\\P999 of the number of accesses to different resources</li><li><code>The time consumed of query data exchange(avg\\50%\\99%\\99.9%)</code>: the average\\median\\P99\\P999 value of query data exchange time consumption</li><li><code>The count of data exchange(avg)</code>: the average number of query data exchange</li><li><code>The count of data exchange</code>: the distribution of the number of query data exchange (minimum, lower quartile, median, upper quartile, maximum)</li><li><code>The number of query queue</code>: the size of different query queues</li><li><code>The time consumed of query schedule time(avg\\50%\\99%\\99.9%)</code>: the average\\median\\P99\\P999 value of query task scheduling time</li></ul></li><li><code>Query Interface</code>: Query files/time-consuming specific time-consuming conditions <ul><li><code>The time consumed of load timesereis metadata(avg\\50%\\99%\\99.9%)</code>: the average\\median\\P99\\P999 value of the time query spent loading timeseries metadata from different sources</li><li><code>The time consumed of read timeseries metadata(avg\\50%\\99%\\99.9%)</code>: the average\\median\\P99\\P999 value of time query spent reading time seriesmetadata from different sources value</li><li><code>The time consumed of timeseries metadata modification(avg\\50%\\99%\\99.9%)</code>: the average\\median\\P99\\P999 value of the time query consumed to modify different types of timeseries metadata</li><li><code>The time consumed of load chunk metadata list(avg\\50%\\99%\\99.9%)</code>: the average\\median\\P99\\P999 value of the time query spent loading different types of chunk metadata</li><li><code>The time consumed of chunk metadata modification(avg\\50%\\99%\\99.9%)</code>: the average\\median\\P99\\P999 value of the time query consumed to modify different types of chunk metadata</li><li><code>The time consumed of chunk metadata filter(avg\\50%\\99%\\99.9%)</code>: the average\\median\\P99\\P999 value of the time query spent to filter different types of chunk metadata</li><li><code>The time consumed of construct chunk reader(avg\\50%\\99%\\99.9%)</code>: the average\\median\\P99\\P999 value of the time query spent on constructing different types of chunk readers</li><li><code>The time consumed of read chunk(avg\\50%\\99%\\99.9%)</code>: the average\\median\\P99\\P999 value of the time query consumed to read different types of Chunk</li><li><code>The time consumed of init chunk reader(avg\\50%\\99%\\99.9%)</code>: the average\\median\\P99\\P999 value of the time query consumed to initialize different types of chunk readers</li><li><code>The time consumed of build tsblock from page reader(avg\\50%\\99%\\99.9%)</code>: the average\\median\\P99\\P999 value of the time query consumed to construct TsBlock from Page Reader</li><li><code>The time consumed of build tsblock from merge reader(avg\\50%\\99%\\99.9%)</code>: the average\\median\\P99\\P999 value of the time query consumed to construct TsBlock from Merge Reader</li></ul></li><li><code>Query Data Exchange</code>: Query the specific time-consuming situation of data transmission <ul><li><code>The time consumed of source handle get tsblock(avg\\50%\\99%\\99.9%)</code>: the average\\median\\P99\\P999 value of the time query consumed to obtain TsBlock from different sources</li><li><code>The time consumed of source handle deserialize tsblock(avg\\50%\\99%\\99.9%)</code>: the average\\median\\P99\\P999 of the time query consumed to deserialize TsBlock from different sources value</li><li><code>The time consumed of sink handle send tsblock(avg\\50%\\99%\\99.9%)</code>: the average\\median\\P99\\P999 value of the time query spent sending TsBlock to different places</li><li><code>The time consumed of on acknowledge data block event task(avg\\50%\\99%\\99.9%)</code>: the average\\median\\P99\\P999 value of time query consumed to acknowlege data block event from different places</li><li><code>The time consumed of get data block event task(avg\\50%\\99%\\99.9%)</code>: query the average\\median\\P99\\P999 value of time query consumed to get data block from different places</li></ul></li><li><code>Engine</code>: <ul><li><code>Task Number</code>: the number of tasks in different states in the system</li><li><code>The Time Consumed Of Tasking</code>: Time consumption of tasks in different states in the system</li><li><code>Compaction Read And Write Per Minute</code>: the average amount of combined read and write data per minute</li><li><code>Compaction R/W Ratio Per Minute</code>: The average ratio of combined read and write data per minute</li><li><code>Compaction Number Per Minute</code>: the average number of different types of consolidation tasks per minute</li></ul></li><li><code>IoTConsensus</code>： <ul><li><code>IoTConsensus Used Memory</code>：The size of the memory used by IoTConsensus consensus</li><li><code>IoTConsensus Sync Index</code>：the searchIndex and safeIndex of region</li><li><code>IoTConsensus Overview</code>：The total sync lag and total size of buffered requests of node</li><li><code>The time consumed of different stages(50%)</code>：The median of the time consumed of different stages</li><li><code>The time consumed of different stages(99%)</code>：The P99 of the time consumed of different stages</li><li><code>The time consumed of different stages(99.9%)</code>：The P999 of the time consumed of different stages</li><li><code>IoTConsensus Search Index Rate</code>：The increasing rate of searchIndex of region</li><li><code>IoTConsensus Safe Index Rate</code>：The increasing rate of safeIndex of region</li><li><code>IoTConsensus LogDispatcher Request Size</code>：The number of requests buffered in logDispatcher</li><li><code>Sync Lag</code>：The sync lag of region</li><li><code>Min Peer Sync Lag</code>：The sync lag between the searchIndex of IoTConsensusServerImpl and the max currentSyncIndex of LogDispatcher</li><li><code>Sync speed diff of Peers</code>：The sync lag between the max currentSyncIndex of LogDispatcher and the min currentSyncIndex of LogDispatcher</li></ul></li><li><code>System</code>: system <ul><li><code>CPU Core</code>: the number of CPU cores in the system.</li><li><code>CPU Load</code>: system CPU load, progress CPU load.</li><li><code>CPU Time Per Minute</code>: The process takes up the system CPU time per minute on average. Note: multi-core will cause this value to exceed 1 minute.</li><li><code>System Memory</code>: the physical memory size of the system, the physical memory size used by the system, and the memory size submitted by the virtual machine.</li><li><code>System Swap Size</code>: the total size of the system swap area, the size used by the system swap area.</li><li><code>Process Memory</code>: the maximum total memory size of the IoTDB process, the total memory size of the IoTDB process, and the memory size used by the IoTDB process.</li><li><code>The Size Of File</code>: IoTDB system-related file size, including the total file size under wal, the total size of tsfile files under seq, and the total size of tsfile files under unseq</li><li><code>The Number Of File</code>: the number of files related to the IoTDB system, including the number of files under wal, the number of tsfile files under seq, and the number of tsfile files under unseq</li><li><code>The Space Of Disk</code>: the total size and remaining size of the disk mounted in the current data directory</li><li><code>The Number of GC Per Minute</code>: The average number of GC per minute.</li><li><code>The Time Consumed Of GC Per Minute</code>: Average GC time spent per minute.</li><li><code>The Number Of Java Thread</code>: The number of threads in different states of the IoTDB process.</li><li><code>Heap Memory</code>: the heap memory of the IoTDB process</li><li><code>Off Heap Memory</code>: the off-heap memory of the IoTDB process</li><li><code>Log Number Per Minute</code>: the average number of logs per minute of the IoTDB process</li><li><code>The Time Consumed of Compliation Per Minute</code>: average compilation time per minute</li><li><code>The Number Of Class</code>: The number of classes loaded and unloaded by the JVM</li></ul></li></ul><h5 id="_5-2-4-4-apache-iotdb-performance-overview-dashboard-说明" tabindex="-1"><a class="header-anchor" href="#_5-2-4-4-apache-iotdb-performance-overview-dashboard-说明" aria-hidden="true">#</a> 5.2.4.4. Apache IoTDB Performance Overview Dashboard 说明</h5><blockquote><p>Except for the metrics specified specially, the following metrics are guaranteed to be available in the monitoring framework at the Core levels.</p></blockquote><ul><li><code>Overview</code>: system overview <ul><li><code>CPU Core</code>: the number of CPU cores in the system.</li><li><code>Total Disk Space</code>: The total size of the disk mounted in the system data directory</li><li><code>System Memory</code>: total system memory size</li><li><code>Swap Memory</code>: System swap area memory size</li><li><code>Total Timeseries</code>: the total number of current time series in the system</li><li><code>Total File Number</code>: total number of system files</li><li><code>CPU Load</code>: System CPU load rate in %</li><li><code>Disk</code>: the proportion of the system Disk, in %</li><li><code>Process Memory</code>: Process memory usage in %</li><li><code>System Memory</code>: System memory usage in %</li><li><code>Write Point Per Second</code>: the number of points written by the system per second</li></ul></li><li><code>Performance</code>: system performance <ul><li><code>OPS</code>: system interface and RPC visits per second</li><li><code>OPS Of Stage</code>: the number of executions per second of each part of the Stage</li><li><code>OPS Of Schedule</code>: the number of executions per second for each part of the Schedule</li><li><code>Time Consumed Of Operation</code>: the time consumption of different operations</li><li><code>P99 Time Consumed of Interface</code>: P99 time consumption of different interfaces</li><li><code>Average Time Consumed of Interface</code>: the average time consumption of different interfaces</li><li><code>P99 Time Consumed of Stage</code>: P99 time consumption in different stages</li><li><code>Average Time Consumed of Stage</code>: the average time consumption of different stages</li><li><code>P99 Time Consumed of Schedule Stage</code>: P99 time consumption in different Schedule stages</li><li><code>Average Time Consumed of Schedule Stage</code>: The average time spent in different Schedule stages</li><li><code>Task Number</code>: the number of tasks</li><li><code>P99 Time Consumed of Task</code>: P99 time consumption of the task</li><li><code>Average Time Consumed of Task</code>: The average time consumption of the task</li></ul></li><li><code>System</code>: system <ul><li><code>CPU Load</code>: CPU load changes</li><li><code>CPU Time Per Minute</code>: The average CPU time spent per minute</li><li><code>GC Time Per Minute</code>: GC average time spent per minute</li><li><code>Heap Memory</code>: the heap memory of the IoTDB process</li><li><code>Off Heap Memory</code>: the off-heap memory of the IoTDB process</li><li><code>The Number Of Java Thread</code>: The number of threads in different states of the IoTDB process.</li><li><code>File Count</code>: Changes in the number of files</li><li><code>File Size</code>: file size changes</li><li><code>Log Number Per Minute</code>: Log changes per minute</li></ul></li></ul><h3 id="_5-3-iotdb" tabindex="-1"><a class="header-anchor" href="#_5-3-iotdb" aria-hidden="true">#</a> 5.3. IoTDB</h3><h4 id="_5-3-1-iotdb-mapping-relationship-of-metrics" tabindex="-1"><a class="header-anchor" href="#_5-3-1-iotdb-mapping-relationship-of-metrics" aria-hidden="true">#</a> 5.3.1. IoTDB mapping relationship of metrics</h4><blockquote><p>For metrics whose Metric Name is name and Tags are K1=V1, ..., Kn=Vn, the mapping is as follows, taking root.__ system.metric.<code>clusterName</code>.<code>nodeType</code>.<code>nodeId</code> as an example by default</p></blockquote><table><thead><tr><th>Metric Type</th><th>Mapping</th></tr></thead><tbody><tr><td>Counter</td><td>root.__system.metric.<code>clusterName</code>.<code>nodeType</code>.<code>nodeId</code>.name.<code>K1=V1</code>...<code>Kn=Vn</code>.value</td></tr><tr><td>AutoGauge、Gauge</td><td>root.__system.metric.<code>clusterName</code>.<code>nodeType</code>.<code>nodeId</code>.name.<code>K1=V1</code>...<code>Kn=Vn</code>.value</td></tr><tr><td>Histogram</td><td>root.__system.metric.<code>clusterName</code>.<code>nodeType</code>.<code>nodeId</code>.name.<code>K1=V1</code>...<code>Kn=Vn</code>.count <br> root.__system.metric.<code>clusterName</code>.<code>nodeType</code>.<code>nodeId</code>.name.<code>K1=V1</code>...<code>Kn=Vn</code>.max <br> root.__system.metric.<code>clusterName</code>.<code>nodeType</code>.<code>nodeId</code>.name.<code>K1=V1</code>...<code>Kn=Vn</code>.sum <br> root.__system.metric.<code>clusterName</code>.<code>nodeType</code>.<code>nodeId</code>.name.<code>K1=V1</code>...<code>Kn=Vn</code>.p0 <br> root.__system.metric.<code>clusterName</code>.<code>nodeType</code>.<code>nodeId</code>.name.<code>K1=V1</code>...<code>Kn=Vn</code>.p50 <br> root.__system.metric.<code>clusterName</code>.<code>nodeType</code>.<code>nodeId</code>.name.<code>K1=V1</code>...<code>Kn=Vn</code>.p75 <br> root.__system.metric.<code>clusterName</code>.<code>nodeType</code>.<code>nodeId</code>.name.<code>K1=V1</code>...<code>Kn=Vn</code>.p99 <br> root.__system.metric.<code>clusterName</code>.<code>nodeType</code>.<code>nodeId</code>.name.<code>K1=V1</code>...<code>Kn=Vn</code>.p999</td></tr><tr><td>Rate</td><td>root.__system.metric.<code>clusterName</code>.<code>nodeType</code>.<code>nodeId</code>.name.<code>K1=V1</code>...<code>Kn=Vn</code>.count <br> root.__system.metric.<code>clusterName</code>.<code>nodeType</code>.<code>nodeId</code>.name.<code>K1=V1</code>...<code>Kn=Vn</code>.mean <br> root.__system.metric.<code>clusterName</code>.<code>nodeType</code>.<code>nodeId</code>.name.<code>K1=V1</code>...<code>Kn=Vn</code>.m1 <br> root.__system.metric.<code>clusterName</code>.<code>nodeType</code>.<code>nodeId</code>.name.<code>K1=V1</code>...<code>Kn=Vn</code>.m5 <br> root.__system.metric.<code>clusterName</code>.<code>nodeType</code>.<code>nodeId</code>.name.<code>K1=V1</code>...<code>Kn=Vn</code>.m15</td></tr><tr><td>Timer</td><td>root.__system.metric.<code>clusterName</code>.<code>nodeType</code>.<code>nodeId</code>.name.<code>K1=V1</code>...<code>Kn=Vn</code>.count <br> root.__system.metric.<code>clusterName</code>.<code>nodeType</code>.<code>nodeId</code>.name.<code>K1=V1</code>...<code>Kn=Vn</code>.max <br> root.__system.metric.<code>clusterName</code>.<code>nodeType</code>.<code>nodeId</code>.name.<code>K1=V1</code>...<code>Kn=Vn</code>.mean <br> root.__system.metric.<code>clusterName</code>.<code>nodeType</code>.<code>nodeId</code>.name.<code>K1=V1</code>...<code>Kn=Vn</code>.sum <br> root.__system.metric.<code>clusterName</code>.<code>nodeType</code>.<code>nodeId</code>.name.<code>K1=V1</code>...<code>Kn=Vn</code>.p0 <br> root.__system.metric.<code>clusterName</code>.<code>nodeType</code>.<code>nodeId</code>.name.<code>K1=V1</code>...<code>Kn=Vn</code>.p50 <br> root.__system.metric.<code>clusterName</code>.<code>nodeType</code>.<code>nodeId</code>.name.<code>K1=V1</code>...<code>Kn=Vn</code>.p75 <br> root.__system.metric.<code>clusterName</code>.<code>nodeType</code>.<code>nodeId</code>.name.<code>K1=V1</code>...<code>Kn=Vn</code>.p99 <br> root.__system.metric.<code>clusterName</code>.<code>nodeType</code>.<code>nodeId</code>.name.<code>K1=V1</code>...<code>Kn=Vn</code>.p999 <br> root.__system.metric.<code>clusterName</code>.<code>nodeType</code>.<code>nodeId</code>.name.<code>K1=V1</code>...<code>Kn=Vn</code>.m1 <br> root.__system.metric.<code>clusterName</code>.<code>nodeType</code>.<code>nodeId</code>.name.<code>K1=V1</code>...<code>Kn=Vn</code>.m5 <br> root.__system.metric.<code>clusterName</code>.<code>nodeType</code>.<code>nodeId</code>.name.<code>K1=V1</code>...<code>Kn=Vn</code>.m15</td></tr></tbody></table><h4 id="_5-3-2-obtain-metrics" tabindex="-1"><a class="header-anchor" href="#_5-3-2-obtain-metrics" aria-hidden="true">#</a> 5.3.2. Obtain metrics</h4><p>According to the above mapping relationship, related IoTDB query statements can be formed to obtain metrics</p>',16);function M(N,S){const o=p("ExternalLinkIcon");return m(),l("div",null,[h(`

    Licensed to the Apache Software Foundation (ASF) under one
    or more contributor license agreements.  See the NOTICE file
    distributed with this work for additional information
    regarding copyright ownership.  The ASF licenses this file
    to you under the Apache License, Version 2.0 (the
    "License"); you may not use this file except in compliance
    with the License.  You may obtain a copy of the License at
    
        http://www.apache.org/licenses/LICENSE-2.0
    
    Unless required by applicable law or agreed to in writing,
    software distributed under the License is distributed on an
    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, either express or implied.  See the License for the
    specific language governing permissions and limitations
    under the License.

`),q,e("p",null,[t("If you want to add your own metrics data in IoTDB, please see the [IoTDB Metric Framework] ("),e("a",g,[t("https://github.com/apache/iotdb/tree/master/metrics"),d(o)]),t(") document.")]),y,_,b,T,v,e("p",null,[e("a",k,[t("Prometheus getting_started"),d(o)])]),e("p",null,[e("a",I,[t("Prometheus scrape metrics"),d(o)])]),e("p",null,[e("a",x,[t("Grafana getting_started"),d(o)])]),e("p",null,[e("a",w,[t("Grafana query metrics from Prometheus"),d(o)])]),C,e("ol",null,[P,e("li",null,[t("You can visit "),e("a",D,[t("Grafana Dashboard official website"),d(o)]),t(", search for "),A,t(" and use")])]),G])}const z=c(f,[["render",M],["__file","Metric-Tool.html.vue"]]);export{z as default};